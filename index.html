<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hockey Scout Sheet</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;

        const Upload = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
            </svg>
        );
        
        const Settings = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m5.2-13.8l-1 1.7m-4.4 7.6l-1 1.7M23 12h-6m-6 0H5m13.8 5.2l-1.7-1m-7.6-4.4l-1.7-1"/>
            </svg>
        );
        
        const Printer = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/>
            </svg>
        );

        const X = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );

        const HockeyLinesChart = () => {
          const [myTeamSetup, setMyTeamSetup] = useState({
            teamName: 'Delano Tigers',
            logo: null,
            colors: { primary: '#fb923c', secondary: '#1f2937' },
            arena: 'Delano Area Sports Arena, Delano',
            careerStats: {}, // Will store career totals by player ID
            pronunciations: {}, // lastName: pronunciation mapping
            careerSeasonData: {
              season1: '', // 2024-25 (current/most recent)
              season2: '', // 2023-24
              season3: ''  // 2022-23
            }
          });

          const [myTeamData, setMyTeamData] = useState({
            teamName: '',
            nickname: '',
            record: { w: 0, l: 0, t: 0 },
            section: '2A',
            conference: 'WCC',
            stats: { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 },
            roster: [],
            nextGame: { gameNum: '', opponent: '', date: '', location: '', oppRecord: '', oppSection: '', oppConference: '' },
            headCoach: { name: '', careerRecord: { w: 0, l: 0, t: 0 }, seasonRecord: { w: 0, l: 0, t: 0 } },
            studentManager: '',
            injuries: []
          });

          const [opponentData, setOpponentData] = useState({
            teamName: '',
            nickname: '',
            record: { w: 0, l: 0, t: 0 },
            section: '',
            conference: '',
            stats: { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 },
            roster: [],
            headCoach: { name: '', careerRecord: { w: 0, l: 0, t: 0 }, seasonRecord: { w: 0, l: 0, t: 0 } }
          });

          const [lines, setLines] = useState({
            line1: { lw: null, c: null, rw: null, color: 'GREEN' },
            line2: { lw: null, c: null, rw: null, color: 'RED' },
            line3: { lw: null, c: null, rw: null, color: 'BLUE' },
            line4: { lw: null, c: null, rw: null, color: 'YELLOW' },
            d1: { ld: null, rd: null },
            d2: { ld: null, rd: null },
            d3: { ld: null, rd: null },
            goalies: { starter: null, backup: null }
          });

          const [coachNotes, setCoachNotes] = useState({
            pk: '',
            pp: '',
            scoutNotes: { powerPlay: '', penaltyKill: '', keyPlayers: '' },
            showScoutNotes: true
          });
          
          const [diagramImages, setDiagramImages] = useState({
            image1: null,
            image2: null,
            image3: null
          });

          const [showSetup, setShowSetup] = useState(false);
          const [showImport, setShowImport] = useState(false);
          const [showColorPicker, setShowColorPicker] = useState(false);
          const [importStep, setImportStep] = useState('myTeamHome');
          const [importText, setImportText] = useState('');
          const [spreadsheetData, setSpreadsheetData] = useState([]);
          const [spreadsheetHeaders, setSpreadsheetHeaders] = useState([]);
          
          // Determine if current step should use spreadsheet view
          const isSpreadsheetStep = (step) => {
            return false; // Disabled - using simple text import for all
          };
          
          // Parse pasted spreadsheet data
          const handleSpreadsheetPaste = (text) => {
            console.log('=== Parsing spreadsheet paste ===');
            console.log('Raw text length:', text.length);
            console.log('First 200 chars:', text.substring(0, 200));
            
            const lines = text.split('\n').filter(l => l.trim());
            console.log('Total lines:', lines.length);
            console.log('First line:', lines[0]);
            
            const rows = lines.map(line => line.split('\t'));
            console.log('First row split by tabs:', rows[0]);
            console.log('First row length:', rows[0].length);
            
            if (rows.length > 0) {
              setSpreadsheetHeaders(rows[0]); // First row is headers
              setSpreadsheetData(rows.slice(1)); // Rest is data
              console.log('Set headers:', rows[0]);
              console.log('Set data rows:', rows.length - 1);
            }
          };
          
          // Process spreadsheet data into player stats
          const processSpreadsheetStats = (headers, data, existingRoster) => {
            // Find column indices
            const getColIndex = (possibleNames) => {
              return headers.findIndex(h => possibleNames.some(name => 
                h.toLowerCase().includes(name.toLowerCase())
              ));
            };
            
            const numCol = getColIndex(['#', 'number']);
            const nameCol = getColIndex(['name', 'player']);
            const gpCol = getColIndex(['gp']);
            const gCol = getColIndex(['g', 'goals']) !== -1 && !headers[getColIndex(['g', 'goals'])].toLowerCase().includes('ga') ? getColIndex(['g', 'goals']) : -1;
            const aCol = getColIndex(['a', 'assists']);
            const ptsCol = getColIndex(['pts', 'points']);
            const ppgCol = getColIndex(['ppg']);
            const ppaCol = getColIndex(['ppa']);
            const shCol = getColIndex(['sh']);
            const shaCol = getColIndex(['sha']);
            const pimCol = getColIndex(['pim', 'pen']);
            const plusMinusCol = getColIndex(['+/-', 'plus', 'minus']);
            const fowCol = getColIndex(['fow']);
            const folCol = getColIndex(['fol']);
            
            // Update roster with stats
            const updatedRoster = existingRoster.map(player => {
              // Find matching row by name or number
              const matchingRow = data.find(row => {
                const rowName = nameCol >= 0 ? row[nameCol] : '';
                const rowNum = numCol >= 0 ? row[numCol] : '';
                return rowName.includes(player.lastName) || rowNum === player.number;
              });
              
              if (matchingRow) {
                return {
                  ...player,
                  stats: {
                    gp: gpCol >= 0 ? parseInt(matchingRow[gpCol]) || 0 : 0,
                    g: gCol >= 0 ? parseInt(matchingRow[gCol]) || 0 : 0,
                    a: aCol >= 0 ? parseInt(matchingRow[aCol]) || 0 : 0,
                    pts: ptsCol >= 0 ? parseInt(matchingRow[ptsCol]) || 0 : 0,
                    ppg: ppgCol >= 0 ? parseInt(matchingRow[ppgCol]) || 0 : 0,
                    ppa: ppaCol >= 0 ? parseInt(matchingRow[ppaCol]) || 0 : 0,
                    sh: shCol >= 0 ? parseInt(matchingRow[shCol]) || 0 : 0,
                    sha: shaCol >= 0 ? parseInt(matchingRow[shaCol]) || 0 : 0,
                    pim: pimCol >= 0 ? parseInt(matchingRow[pimCol]) || 0 : 0,
                    plusMinus: plusMinusCol >= 0 ? parseInt(matchingRow[plusMinusCol]) || 0 : 0,
                    fow: fowCol >= 0 ? parseInt(matchingRow[fowCol]) || 0 : 0,
                    fol: folCol >= 0 ? parseInt(matchingRow[folCol]) || 0 : 0
                  }
                };
              }
              
              return player;
            });
            
            return updatedRoster;
          };
          const [draggedPlayer, setDraggedPlayer] = useState(null);
          const [dragSource, setDragSource] = useState(null);
          const [opponentLogo, setOpponentLogo] = useState(null);
          const [opponentColors, setOpponentColors] = useState({ primary: '#dc2626', secondary: '#991b1b' });
          const [careerStatsImport, setCareerStatsImport] = useState({
            lastSeason: '',
            twoSeasonsAgo: '',
            threeSeasonsAgo: ''
          });

          const colorOptions = ['GREEN', 'RED', 'BLUE', 'YELLOW'];
          const colorClasses = {
            'GREEN': 'bg-green-100 border-green-600',
            'RED': 'bg-red-100 border-red-600',
            'BLUE': 'bg-blue-100 border-blue-600',
            'YELLOW': 'bg-yellow-100 border-yellow-600'
          };

          const importSteps = [
  { key: 'myTeamHome', label: 'My Team - Legacy Home', team: 'mine' },
  { key: 'myTeamRoster', label: 'My Team - Legacy Roster', team: 'mine' },
  { key: 'myTeamPlayerStats', label: 'My Team - Legacy Player Stats', team: 'mine' },
  { key: 'oppLogo', label: 'Opponent - Logo', team: 'opponent', isLogo: true },
  { key: 'oppHome', label: 'Opponent - Legacy Home', team: 'opponent' },
  { key: 'oppRoster', label: 'Opponent - Legacy Roster', team: 'opponent' },
  { key: 'oppPlayerStats', label: 'Opponent - Legacy Player Stats', team: 'opponent' }
];

          useEffect(() => {
            const saved = localStorage.getItem('myTeamSetup');
            if (saved) {
              setMyTeamSetup(JSON.parse(saved));
            }
          }, []);

          useEffect(() => {
            localStorage.setItem('myTeamSetup', JSON.stringify(myTeamSetup));
          }, [myTeamSetup]);

          // Career Stats localStorage helpers
          const saveCareerStatsToStorage = (roster) => {
            const careerData = {};
            roster.forEach(player => {
              const key = `${player.lastName?.toUpperCase()}_${player.firstName?.charAt(0)?.toUpperCase()}`;
              
              if (player.baseCareerStats && player.baseCareerStats.gp > 0) {
                careerData[key] = {
                  type: 'skater',
                  data: player.baseCareerStats
                };
              }
              
              if (player.baseCareerGoalieStats && player.baseCareerGoalieStats.gp > 0) {
                careerData[key] = {
                  type: 'goalie',
                  data: player.baseCareerGoalieStats
                };
              }
            });
            
            localStorage.setItem('hockey-scout-career-stats', JSON.stringify(careerData));
            console.log('💾 Saved career stats to localStorage:', Object.keys(careerData).length, 'players');
          };
          
          const loadCareerStatsFromStorage = (roster) => {
            console.log('🔍 loadCareerStatsFromStorage CALLED with roster size:', roster.length);
            const stored = localStorage.getItem('hockey-scout-career-stats');
            console.log('🔍 localStorage contains:', stored ? 'YES' : 'NO');
            
            if (!stored) {
              console.log('❌ No career stats in localStorage');
              return roster;
            }
            
            const careerData = JSON.parse(stored);
            console.log('📂 Loading career stats from localStorage:', Object.keys(careerData).length, 'players');
            console.log('📂 Career data keys:', Object.keys(careerData));
            
            return roster.map(player => {
              const key = `${player.lastName?.toUpperCase()}_${player.firstName?.charAt(0)?.toUpperCase()}`;
              console.log(`🔍 Looking for key: ${key} for player: ${player.name} (Position: ${player.position})`);
              const savedCareer = careerData[key];
              
              if (savedCareer) {
                console.log(`✅ Found saved career for ${player.name}:`, savedCareer);
                
                // If player is a goalie in the roster, load goalie stats
                if (player.position === 'G' && savedCareer.type === 'goalie') {
                  player.baseCareerGoalieStats = savedCareer.data;
                  console.log(`✅ Loaded GOALIE career for ${player.name}`);
                } else if (savedCareer.type === 'skater') {
                  player.baseCareerStats = savedCareer.data;
                  console.log(`✅ Loaded SKATER career for ${player.name}`);
                }
              } else {
                console.log(`❌ No saved career found for ${player.name} (key: ${key})`);
              }
              
              return player;
            });
          };

          const parseHomePage = (text) => {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            let teamName = '';
            let nickname = '';
            let record = { w: 0, l: 0, t: 0 };
            let section = '';
            let conference = '';
            let headCoach = { name: '', careerRecord: { w: 0, l: 0, t: 0 }, seasonRecord: { w: 0, l: 0, t: 0 } };
            
            // Find team name - look for line that appears between "Subscribe" and "History"
            const subscribeIdx = lines.findIndex(l => l === 'Subscribe');
            const historyIdx = lines.findIndex(l => l === 'History');
            if (subscribeIdx >= 0 && historyIdx > subscribeIdx && historyIdx - subscribeIdx <= 3) {
              teamName = lines[subscribeIdx + 1];
            }
            
            // Find nickname - look for "Nickname:" line
            const nicknameIdx = lines.findIndex(l => l.startsWith('Nickname:'));
            if (nicknameIdx >= 0) {
              nickname = lines[nicknameIdx].split(':')[1]?.trim() || '';
            }
            
            // Look for the team record line - format: "15 11 1" (W L T)
for (let i = 0; i < lines.length; i++) {
  // Look for "Team Record" header followed by the stats
  if (lines[i].includes('Team Record') || lines[i].includes('TeamWLT')) {
    // The next line with 3 numbers is the record
    for (let j = i; j < i + 5; j++) {
      const parts = lines[j]?.split(/\s+/);
      if (parts && parts.length >= 3 && /^\d+$/.test(parts[0]) && /^\d+$/.test(parts[1]) && /^\d+$/.test(parts[2])) {
        record = { w: parseInt(parts[0]), l: parseInt(parts[1]), t: parseInt(parts[2]) };
        break;
      }
    }
    break;
  }
}
            
            const coachIdx = lines.findIndex(l => l.includes('Head Coach'));
            if (coachIdx >= 0 && coachIdx + 1 < lines.length) {
              headCoach.name = lines[coachIdx + 1];
              
              // Look for the career record in the next several lines
              // Format: "11th season, 191-84-5"
              for (let i = coachIdx + 1; i < coachIdx + 6 && i < lines.length; i++) {
                const careerLine = lines[i];
                const careerMatch = careerLine.match(/(\d+)-(\d+)-(\d+)/);
                
                if (careerMatch && careerLine.includes('season')) {
                  // Has career record
                  headCoach.careerRecord = { 
                    w: parseInt(careerMatch[1]), 
                    l: parseInt(careerMatch[2]), 
                    t: parseInt(careerMatch[3]) 
                  };
                  break;
                } else if (careerLine.includes('1st Year') || careerLine.includes('1st year')) {
                  // First year coach - NO career yet, will show current season only
                  headCoach.careerRecord = { w: 0, l: 0, t: 0 };
                  break;
                }
              }
              
              // Store current season record
              headCoach.seasonRecord = { ...record };
            }
            
            const sectionIdx = lines.findIndex(l => l.includes('Section:'));
            if (sectionIdx >= 0) section = lines[sectionIdx].split(':')[1]?.trim() || '';
            
            const confIdx = lines.findIndex(l => l.includes('Conference:'));
            if (confIdx >= 0) conference = lines[confIdx].split(':')[1]?.trim() || '';
            
            let stats = { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 };
            for (let i = 0; i < lines.length; i++) {
              const parts = lines[i].split(/\s+/);
              if (parts.length >= 10 && parts[0].match(/\d+/)) {
                stats.gpg = parseFloat(parts[3]) || 0;
                stats.gapg = parseFloat(parts[4]) || 0;
                stats.ppPct = parseFloat(parts[6]) || 0;
                stats.pkPct = parseFloat(parts[9]) || 0;
                break;
              }
            }
            
            // Parse Last Game
            // Format: "Last Game" -> score -> "Final" -> Scoreboard with team names
            // Team    1  2  3  T
            // Orono   0  2  3  5
            // Hibbing/Chisholm 0  0  1  1
            let lastGame = null;
            const lastGameIdx = lines.findIndex(l => l === 'Last Game');
            if (lastGameIdx >= 0) {
              const scoreLine = lines[lastGameIdx + 1];
              const scoreMatch = scoreLine?.match(/(\d+)\s*-\s*(\d+)/);
              
              if (scoreMatch) {
                const leftScore = parseInt(scoreMatch[1]);
                const rightScore = parseInt(scoreMatch[2]);
                
                // Find opponent in scoreboard - look for "Team" header, then find the line that's NOT our team
                let opponent = '';
                const teamHeaderIdx = lines.findIndex((l, idx) => idx > lastGameIdx && l.includes('Team') && l.includes('1') && l.includes('2'));
                
                if (teamHeaderIdx > 0) {
                  // Next 2-3 lines after "Team" header are team names with scores
                  for (let i = teamHeaderIdx + 1; i < Math.min(lines.length, teamHeaderIdx + 4); i++) {
                    const line = lines[i];
                    // Line should have team name followed by numbers (scores)
                    // Match: "Hibbing/Chisholm 0  0  1  1" or similar
                    const teamMatch = line.match(/^([A-Za-z\/\s-]+?)\s+\d/);
                    if (teamMatch) {
                      const potentialTeam = teamMatch[1].trim();
                      // Skip if it's our team name
                      if (potentialTeam.toLowerCase() !== teamName.toLowerCase()) {
                        // Capitalize properly
                        opponent = potentialTeam.split(' ').map(word => 
                          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                        ).join(' ');
                        break;
                      }
                    }
                  }
                }
                
                // Fallback: look for "Final" then next substantive line
                if (!opponent) {
                  const finalIdx = lines.findIndex((l, idx) => idx > lastGameIdx && l === 'Final');
                  if (finalIdx > 0) {
                    for (let i = finalIdx + 1; i < Math.min(lines.length, finalIdx + 4); i++) {
                      const line = lines[i];
                      if (line && line.length > 2 && line !== teamName && !line.includes('202') && !line.includes('@')) {
                        opponent = line.split(' ').map(word => 
                          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                        ).join(' ');
                        break;
                      }
                    }
                  }
                }
                
                // Find date/location
                let date = '';
                let location = '';
                for (let i = lastGameIdx + 3; i < Math.min(lines.length, lastGameIdx + 15); i++) {
                  if (lines[i].includes('@') && lines[i].includes('202')) {
                    const parts = lines[i].split('|');
                    date = parts[0]?.trim() || lines[i];
                    location = parts[1]?.trim() || '';
                    break;
                  }
                }
                
                // Determine which score is ours
                const ourScore = rightScore;
                const oppScore = leftScore;
                
                lastGame = {
                  opponent,
                  ourScore,
                  oppScore,
                  result: ourScore > oppScore ? 'W' : ourScore < oppScore ? 'L' : 'T',
                  date,
                  location
                };
              }
            }
            
            // Parse Next Game
            // Format: Our team name -> "AT" or "VS" -> Opponent -> Date with @
            let nextGame = null;
            const nextGameIdx = lines.findIndex(l => l === 'Next Game');
            if (nextGameIdx >= 0) {
              let opponent = '';
              let isHome = false;
              let date = '';
              let time = '';
              
              // Look for "AT" (we're away) or "VS" (we're home)
              for (let i = nextGameIdx + 1; i < Math.min(lines.length, nextGameIdx + 10); i++) {
                if (lines[i] === 'AT') {
                  isHome = false;
                  // Opponent should be 2-3 lines after AT
                  for (let j = i + 1; j < Math.min(lines.length, i + 5); j++) {
                    if (lines[j] && lines[j].length > 2 && lines[j] !== teamName && !lines[j].includes('@')) {
                      opponent = lines[j];
                      break;
                    }
                  }
                  break;
                } else if (lines[i] === 'VS') {
                  isHome = true;
                  // Opponent should be 2-3 lines after VS
                  for (let j = i + 1; j < Math.min(lines.length, i + 5); j++) {
                    if (lines[j] && lines[j].length > 2 && lines[j] !== teamName && !lines[j].includes('@')) {
                      opponent = lines[j];
                      break;
                    }
                  }
                  break;
                }
              }
              
              // Look for date line (contains @ and time like "6:00p")
              for (let i = nextGameIdx + 1; i < Math.min(lines.length, nextGameIdx + 15); i++) {
                if (lines[i].includes('@') && (lines[i].includes(':') || lines[i].includes('p') || lines[i].includes('a'))) {
                  const parts = lines[i].split('@');
                  date = parts[0]?.trim() || '';
                  time = parts[1]?.trim() || '';
                  break;
                }
              }
              
              nextGame = {
                opponent,
                isHome,
                date,
                time,
                gameNum: '' // Will be calculated from record
              };
            }
            
            // Calculate next game number from record (W + L + T + 1)
            if (nextGame) {
              nextGame.gameNum = (record.w + record.l + record.t + 1).toString();
            }
            
            return { teamName, nickname, record, section, conference, headCoach, stats, lastGame, nextGame };
          };

          const parseRoster = (text, existingRoster = []) => {
  console.log('=== parseRoster called ===');
  console.log('Text length:', text.length);
  console.log('Existing roster size:', existingRoster.length);
  const lines = text.split('\n').map(l => l.trim()).filter(l => l);
  console.log('Total lines:', lines.length);
  let roster = [];
  
  // Data is tab-separated on individual lines
  // Format: NUMBER [tab] NAME [tab] POSITION [tab] GRADE [tab] HEIGHT [tab] WEIGHT [tab] SHOOTS/CATCHES [tab] DOB
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Split by tabs
    const fields = line.split('\t').map(f => f.trim()).filter(f => f);
    
    // Valid player line has: number, name, position (F/D/G), grade
    if (fields.length >= 4) {
      const number = fields[0];
      const name = fields[1];
      const position = fields[2];
      const grade = fields[3];
      
      // Check if this looks like a player line
      if (/^\d+$/.test(number) && /^[FDG]$/.test(position) && /^\d{1,2}$/.test(grade)) {
        console.log('✅ Found player:', { number, name, position, grade, fields });
        
        const nameParts = name.split(' ');
        const lastName = nameParts[nameParts.length - 1];
        const firstName = nameParts.slice(0, -1).join(' ');
        
        // Extract handedness from "Shoots" or "Catches" field (usually field 6)
        let handed = '';
        let shoots = ''; // For goalies (catches)
        for (let j = 4; j < fields.length; j++) {
          if (fields[j].includes('Left')) {
            handed = 'L';
            shoots = 'L';
            break;
          } else if (fields[j].includes('Right')) {
            handed = 'R';
            shoots = 'R';
            break;
          }
        }
        
        // Extract DOB year (usually last field, format: "2007" or "12/15/2007")
        let dobYear = '';
        const lastField = fields[fields.length - 1];
        const yearMatch = lastField.match(/\b(19|20)\d{2}\b/);
        if (yearMatch) {
          dobYear = yearMatch[0];
        }
        
        // Check if this player already exists in the existing roster (match by name)
        const existingPlayer = existingRoster.find(p => 
          p.lastName?.toUpperCase() === lastName.toUpperCase() && 
          p.firstName?.charAt(0)?.toUpperCase() === firstName.charAt(0)?.toUpperCase()
        );
        
        roster.push({
          id: `${number}-${lastName}`,
          number: number,
          name: name,
          firstName: firstName,
          lastName: lastName,
          position: position,
          grade: grade,
          dobYear: dobYear,
          handed: handed,
          shoots: shoots,
          stats: { gp: 0, g: 0, a: 0, pts: 0, ppg: 0, ppa: 0, sh: 0, sha: 0, pim: 0, plusMinus: 0, fow: 0, fol: 0 },
          goalieStats: position === 'G' ? { gp: 0, min: '0:00', w: 0, l: 0, t: 0, sog: 0, ga: 0, sv: 0, gaa: 0, svp: '.000', so: 0 } : null,
          // PRESERVE career data if it exists from previous roster
          baseCareerStats: existingPlayer?.baseCareerStats || undefined,
          baseCareerGoalieStats: existingPlayer?.baseCareerGoalieStats || undefined,
          pronunciation: existingPlayer?.pronunciation || undefined
        });
      }
    }
  }
  
  console.log('Final roster size:', roster.length);
  console.log('Roster:', roster);
  return roster;
};

          const parseSchedule = (text) => {
  const lines = text.split('\n').map(l => l.trim());
  let gameNum = 0;
  let nextGame = { gameNum: '', opponent: '', date: '', time: '', location: '', oppRecord: '', oppSection: '', oppConference: '' };
  let lastGame = { gameNum: '', opponent: '', date: '', time: '', location: '', oppRecord: '', oppSection: '', oppConference: '' };
  let foundNextGame = false;
  
  // Parse each game line by line
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Look for date line (starts with day of week) - only count lines that have game info following
    if (line.match(/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)/) && i + 1 < lines.length) {
      // Check if this is actually a game (next line should be score or "-")
      const nextLine = lines[i + 1];
      
      // Skip if next line is empty or doesn't look like a score/dash
      if (!nextLine || (!nextLine.includes('-') && !nextLine.match(/^\d+$/))) {
        continue;
      }
      
      gameNum++;
      
      // Extract game details
      const opponentLine = lines[i + 2] || '';
      const locationLine = lines[i + 3] || '';
      
      // Store as last game
      lastGame.gameNum = gameNum.toString();
      lastGame.date = line;
      lastGame.opponent = opponentLine.replace('@', '').trim();
      lastGame.location = locationLine;
      
      // Check if this game hasn't been played yet (score is just "-")
      if (nextLine === '-' && !foundNextGame) {
        // This is the next unplayed game!
        nextGame = { ...lastGame };
        foundNextGame = true;
      }
    }
  }
  
  // If no unplayed game found, return the last game
  return foundNextGame ? nextGame : lastGame;
};

          const parsePlayerStats = (text, existingRoster) => {
            console.log('=== parsePlayerStats called ===');
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            console.log('Total lines:', lines.length);
            
            const updatedRoster = [...existingRoster];
            let inSkaterSection = false;
            let inGoalieSection = false;
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // Detect sections
              if (line === 'Skater') {
                inSkaterSection = true;
                inGoalieSection = false;
                console.log('Found Skater section at line', i);
                continue;
              }
              if (line === 'Goalie') {
                inSkaterSection = false;
                inGoalieSection = true;
                console.log('Found Goalie section at line', i);
                continue;
              }
              
              // Skip headers
              if (line === '#' || line === 'Name' || line === 'GP' || line.includes('AVG PTS')) continue;
              
              // Split by tabs
              const fields = line.split('\t').filter(f => f.trim());
              
              // Need at least player number and name
              if (fields.length < 3) continue;
              
              const number = fields[0];
              const name = fields[1];
              
              // Must start with a digit
              if (!/^\d+$/.test(number)) continue;
              
              if (inSkaterSection) {
                const player = updatedRoster.find(p => p.number === number && p.position !== 'G');
                
                if (player && fields.length >= 6) {
                  // DEBUG: Check if baseCareer exists
                  if (player.baseCareerStats) {
                    console.log(`🔍 ${name} HAS baseCareer:`, player.baseCareerStats);
                  } else {
                    console.log(`⚠️ ${name} has NO baseCareer (rookie or not imported yet)`);
                  }
                  
                  // Current season stats
                  const currentStats = {
                    gp: parseInt(fields[2]) || 0,
                    g: parseInt(fields[3]) || 0,
                    a: parseInt(fields[4]) || 0,
                    pts: parseInt(fields[5]) || 0,
                    ppg: parseInt(fields[8]) || 0,
                    ppa: parseInt(fields[9]) || 0,
                    sh: parseInt(fields[10]) || 0,
                    sha: parseInt(fields[11]) || 0,
                    pim: parseInt(fields[13]) || 0,
                    fow: parseInt(fields[14]) || 0,
                    fol: parseInt(fields[15]) || 0,
                    plusMinus: parseInt(fields[19]) || 0
                  };
                  
                  player.stats = currentStats;
                  
                  // Career stats = base career (from My Team Setup) + current season
                  // If no baseCareer exists, player is a rookie - career = current only
                  const baseCareer = player.baseCareerStats || { gp: 0, g: 0, a: 0, pts: 0, plusMinus: 0, fow: 0, fol: 0 };
                  const totalFOW = (baseCareer.fow || 0) + currentStats.fow;
                  const totalFOL = (baseCareer.fol || 0) + currentStats.fol;
                  const careerFaceoffPct = (totalFOW + totalFOL > 0) ? ((totalFOW / (totalFOW + totalFOL)) * 100).toFixed(1) : '0.0';
                  
                  player.careerStats = {
                    gp: baseCareer.gp + currentStats.gp,
                    g: baseCareer.g + currentStats.g,
                    a: baseCareer.a + currentStats.a,
                    pts: baseCareer.pts + currentStats.pts,
                    plusMinus: baseCareer.plusMinus + currentStats.plusMinus,
                    faceoffPct: careerFaceoffPct,
                    fow: totalFOW,
                    fol: totalFOL
                  };
                  
                  console.log(`✅ Updated ${name}:`, player.stats, 'Career:', player.careerStats);
                }
              } else if (inGoalieSection) {
                const player = updatedRoster.find(p => p.number === number && p.position === 'G');
                
                if (player && player.goalieStats && fields.length >= 10) {
                  // Current season goalie stats
                  // Columns: # | Name | GP | MIN | W | L | T | SOG | GA | SV | GAA | SV% | SO
                  const currentGoalieStats = {
                    gp: parseInt(fields[2]) || 0,      // GP
                    min: fields[3] || '0:00',          // MIN
                    w: parseInt(fields[4]) || 0,       // W
                    l: parseInt(fields[5]) || 0,       // L
                    t: parseInt(fields[6]) || 0,       // T
                    sog: parseInt(fields[7]) || 0,     // SOG
                    ga: parseInt(fields[8]) || 0,      // GA
                    sv: parseInt(fields[9]) || 0,      // SV
                    gaa: parseFloat(fields[10]) || 0,  // GAA
                    svp: fields[11] || '.000',         // SV%
                    so: parseInt(fields[12]) || 0      // SO
                  };
                  
                  player.goalieStats = currentGoalieStats;
                  
                  // Career = base career (from My Team Setup) + current season
                  console.log(`🔍 ${name} baseCareerGoalieStats:`, player.baseCareerGoalieStats);
                  const baseCareer = player.baseCareerGoalieStats || { gp: 0, min: '0:00', w: 0, l: 0, t: 0, so: 0, ga: 0, sv: 0 };
                  console.log(`🔍 ${name} using baseCareer:`, baseCareer);
                  
                  // Convert minutes to total seconds
                  const parseMinutes = (minStr) => {
                    const parts = minStr.split(':');
                    return parseInt(parts[0]) * 60 + parseInt(parts[1] || 0);
                  };
                  
                  const baseSeconds = parseMinutes(baseCareer.min);
                  const currSeconds = parseMinutes(currentGoalieStats.min);
                  const totalSeconds = baseSeconds + currSeconds;
                  const totalMinStr = `${Math.floor(totalSeconds / 60)}:${String(totalSeconds % 60).padStart(2, '0')}`;
                  
                  const totalGA = baseCareer.ga + currentGoalieStats.ga;
                  const totalSV = baseCareer.sv + currentGoalieStats.sv;
                  const totalSOG = totalGA + totalSV;
                  
                  // Career GAA formula: Total GA / (Total Minutes / 51)
                  const totalMinutes = totalSeconds / 60;
                  const careerGAA = totalMinutes > 0 ? (totalGA / (totalMinutes / 51)).toFixed(2) : '0.00';
                  
                  // Career SV%
                  const careerSVP = totalSOG > 0 ? (totalSV / totalSOG).toFixed(3) : '.000';
                  
                  player.careerGoalieStats = {
                    gp: baseCareer.gp + currentGoalieStats.gp,
                    min: totalMinStr,
                    w: baseCareer.w + currentGoalieStats.w,
                    l: baseCareer.l + currentGoalieStats.l,
                    t: baseCareer.t + currentGoalieStats.t,
                    so: baseCareer.so + currentGoalieStats.so,
                    ga: totalGA,
                    sv: totalSV,
                    gaa: parseFloat(careerGAA),
                    svp: careerSVP
                  };
                  
                  console.log(`✅ Updated goalie ${name}:`, player.goalieStats, 'Career:', player.careerGoalieStats);
                }
              }
            }
            
            console.log('Final updated roster:', updatedRoster);
            return updatedRoster;
          };

          const parseCareerStats = (text, existingRoster) => {
            console.log('=== parseCareerStats called ===');
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            console.log('Total lines:', lines.length);
            
            const updatedRoster = [...existingRoster];
            let inSkaterSection = false;
            let inGoalieSection = false;
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // Detect sections
              if (line === 'Skater') {
                inSkaterSection = true;
                inGoalieSection = false;
                console.log('Found Skater section at line', i);
                continue;
              }
              if (line === 'Goalie') {
                inSkaterSection = false;
                inGoalieSection = true;
                console.log('Found Goalie section at line', i);
                continue;
              }
              
              // Skip headers
              if (line === '#' || line === 'Name' || line === 'GP' || line.includes('AVG PTS')) continue;
              
              // Split by tabs
              const fields = line.split('\t').filter(f => f.trim());
              
              // Need at least player number and name
              if (fields.length < 3) continue;
              
              const number = fields[0];
              const name = fields[1];
              
              // Must start with a digit
              if (!/^\d+$/.test(number)) continue;
              
              if (inSkaterSection) {
                // Normalize number for matching (trim and compare as strings)
                const normalizedNumber = number.trim();
                
                // Extract last name and first initial from career import
                const careerNameParts = name.trim().split(/\s+/);
                const careerFirstInitial = careerNameParts[0]?.charAt(0)?.toUpperCase() || '';
                const careerLastName = careerNameParts[careerNameParts.length - 1]?.toUpperCase() || '';
                
                // Try to match by: 1) Last Name + First Initial (primary), 2) Jersey Number (fallback)
                let player = updatedRoster.find(p => {
                  if (p.position === 'G') return false; // Skip goalies
                  
                  const rosterFirstInitial = p.firstName?.charAt(0)?.toUpperCase() || '';
                  const rosterLastName = p.lastName?.toUpperCase() || '';
                  
                  // Primary match: Last Name + First Initial
                  const nameMatch = rosterLastName === careerLastName && rosterFirstInitial === careerFirstInitial;
                  
                  // Fallback match: Jersey Number (if name doesn't match)
                  const numberMatch = p.number.toString().trim() === normalizedNumber;
                  
                  return nameMatch || numberMatch;
                });
                
                // Log matching attempt
                if (player) {
                  const matchType = (player.lastName?.toUpperCase() === careerLastName && 
                                    player.firstName?.charAt(0)?.toUpperCase() === careerFirstInitial) 
                                    ? 'by NAME' : 'by NUMBER';
                  console.log(`Trying to match skater #${normalizedNumber} (${name}): ✅ FOUND ${matchType} → #${player.number} ${player.name}`);
                } else {
                  console.log(`Trying to match skater #${normalizedNumber} (${name}): ❌ NOT FOUND`);
                }
                
                if (player && fields.length >= 6) {
                  // This season's stats from career import
                  const seasonGP = parseInt(fields[2]) || 0;
                  const seasonG = parseInt(fields[3]) || 0;
                  const seasonA = parseInt(fields[4]) || 0;
                  const seasonPts = parseInt(fields[5]) || 0;
                  const seasonPlusMinus = parseInt(fields[19]) || 0;
                  const seasonFOW = parseInt(fields[14]) || 0;
                  const seasonFOL = parseInt(fields[15]) || 0;
                  
                  // Add to existing base career (for multiple season imports)
                  const existing = player.baseCareerStats || { gp: 0, g: 0, a: 0, pts: 0, plusMinus: 0, fow: 0, fol: 0 };
                  
                  player.baseCareerStats = {
                    gp: existing.gp + seasonGP,
                    g: existing.g + seasonG,
                    a: existing.a + seasonA,
                    pts: existing.pts + seasonPts,
                    plusMinus: existing.plusMinus + seasonPlusMinus,
                    fow: existing.fow + seasonFOW,
                    fol: existing.fol + seasonFOL
                  };
                  
                  console.log(`✅ Base career for ${name}:`, player.baseCareerStats);
                } else if (!player) {
                  console.log(`❌ No roster match for #${normalizedNumber} ${name}`);
                }
              } else if (inGoalieSection) {
                // Normalize number for matching
                const normalizedNumber = number.trim();
                
                // Extract last name and first initial from career import
                const careerNameParts = name.trim().split(/\s+/);
                const careerFirstInitial = careerNameParts[0]?.charAt(0)?.toUpperCase() || '';
                const careerLastName = careerNameParts[careerNameParts.length - 1]?.toUpperCase() || '';
                
                // Try to match by: 1) Last Name + First Initial (primary), 2) Jersey Number (fallback)
                let player = updatedRoster.find(p => {
                  if (p.position !== 'G') return false; // Only goalies
                  
                  const rosterFirstInitial = p.firstName?.charAt(0)?.toUpperCase() || '';
                  const rosterLastName = p.lastName?.toUpperCase() || '';
                  
                  // Primary match: Last Name + First Initial
                  const nameMatch = rosterLastName === careerLastName && rosterFirstInitial === careerFirstInitial;
                  
                  // Fallback match: Jersey Number
                  const numberMatch = p.number.toString().trim() === normalizedNumber;
                  
                  return nameMatch || numberMatch;
                });
                
                // Log matching attempt
                if (player) {
                  const matchType = (player.lastName?.toUpperCase() === careerLastName && 
                                    player.firstName?.charAt(0)?.toUpperCase() === careerFirstInitial) 
                                    ? 'by NAME' : 'by NUMBER';
                  console.log(`Trying to match goalie #${normalizedNumber} (${name}): ✅ FOUND ${matchType} → #${player.number} ${player.name}`);
                } else {
                  console.log(`Trying to match goalie #${normalizedNumber} (${name}): ❌ NOT FOUND`);
                }
                
                if (player && fields.length >= 10) {
                  // Career import goalie stats
                  // Columns: # | Name | GP | MIN | W | L | T | SOG | GA | SV | GAA | SV% | SO
                  const seasonGP = parseInt(fields[2]) || 0;      // GP
                  const seasonMin = fields[3] || '0:00';          // MIN
                  const seasonW = parseInt(fields[4]) || 0;       // W
                  const seasonL = parseInt(fields[5]) || 0;       // L
                  const seasonT = parseInt(fields[6]) || 0;       // T
                  // Skip SOG (fields[7]) - we calculate from GA + SV
                  const seasonGA = parseInt(fields[8]) || 0;      // GA
                  const seasonSV = parseInt(fields[9]) || 0;      // SV
                  // Skip GAA (fields[10]) - we calculate it
                  // Skip SV% (fields[11]) - we calculate it
                  const seasonSO = parseInt(fields[12]) || 0;     // SO
                  
                  // Convert minutes to seconds for accumulation
                  const parseMinutes = (minStr) => {
                    const parts = minStr.split(':');
                    return parseInt(parts[0]) * 60 + parseInt(parts[1] || 0);
                  };
                  
                  const existing = player.baseCareerGoalieStats || { gp: 0, min: '0:00', w: 0, l: 0, t: 0, so: 0, ga: 0, sv: 0 };
                  const existingSeconds = parseMinutes(existing.min);
                  const seasonSeconds = parseMinutes(seasonMin);
                  const totalSeconds = existingSeconds + seasonSeconds;
                  const totalMinStr = `${Math.floor(totalSeconds / 60)}:${String(totalSeconds % 60).padStart(2, '0')}`;
                  
                  player.baseCareerGoalieStats = {
                    gp: existing.gp + seasonGP,
                    min: totalMinStr,
                    w: existing.w + seasonW,
                    l: existing.l + seasonL,
                    t: existing.t + seasonT,
                    so: existing.so + seasonSO,
                    ga: existing.ga + seasonGA,
                    sv: existing.sv + seasonSV
                  };
                  
                  console.log(`✅ Base career goalie for ${name}:`, player.baseCareerGoalieStats);
                } else if (!player) {
                  console.log(`❌ No roster match for goalie #${normalizedNumber} ${name}`);
                }
              }
            }
            
            console.log('Final roster with career stats:', updatedRoster);
            return updatedRoster;
          };

          const parseTeamStats = (text) => {
            console.log('parseTeamStats called with text:', text.substring(0, 200));
            const lines = text.split('\n').map(l => l.trim());
            let stats = { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 };
            
            // Look for the line with team stats - format: Delano 27 4.00 3.15 89 25.8 85 23 72.9
            // We need: GPG (index 2), GAPG (index 3), PP% (index 5), PK% (index 8)
            for (let i = 0; i < lines.length; i++) {
              const parts = lines[i].split(/\s+/);
              
              // Look for line starting with team name and has 9+ fields with the right pattern
              if (parts.length >= 9 && 
                  (parts[0] === 'Delano' || parts[0].includes('Tigers') || /^\d+$/.test(parts[1])) &&
                  parts[2]?.match(/^\d+\.\d+$/) && 
                  parts[3]?.match(/^\d+\.\d+$/)) {
                stats.gpg = parseFloat(parts[2]) || 0;
                stats.gapg = parseFloat(parts[3]) || 0;
                stats.ppPct = parseFloat(parts[5]) || 0;
                stats.pkPct = parseFloat(parts[8]) || 0;
                console.log('Found stats at line:', lines[i]);
                console.log('Parsed stats:', stats);
                break;
              }
            }
            
            console.log('parseTeamStats returning:', stats);
            return stats;
          };

          const handleLogoPaste = async (isSetup, isMyTeam) => {
            try {
              const clipboardItems = await navigator.clipboard.read();
              for (const item of clipboardItems) {
                for (const type of item.types) {
                  if (type.startsWith('image/')) {
                    const blob = await item.getType(type);
                    const reader = new FileReader();
                    reader.onload = (event) => {
                      const logoUrl = event.target.result;
                      
                      if (isSetup) {
                        setMyTeamSetup(prev => ({ ...prev, logo: logoUrl }));
                      } else if (isMyTeam) {
                        setMyTeamSetup(prev => ({ ...prev, logo: logoUrl }));
                      } else {
                        setOpponentLogo(logoUrl);
                      }
                    };
                    reader.readAsDataURL(blob);
                    return;
                  }
                }
              }
              alert('No image found in clipboard.');
            } catch (err) {
              alert('Unable to paste. Please use Choose File or copy an image first.');
            }
          };

          const handleLogoUpload = (e, isSetup, isMyTeam) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
              const logoUrl = event.target.result;
              
              if (isSetup) {
                setMyTeamSetup(prev => ({ ...prev, logo: logoUrl }));
              } else if (isMyTeam) {
                setMyTeamSetup(prev => ({ ...prev, logo: logoUrl }));
              } else {
                setOpponentLogo(logoUrl);
              }
            };
            reader.readAsDataURL(file);
          };

          const handleImport = () => {
            const text = importText;
            console.log('=== handleImport called ===');
            console.log('Current importStep:', importStep);
            console.log('Text length:', text.length);
            
            if (importStep === 'oppLogo') {
              const currentIdx = importSteps.findIndex(s => s.key === importStep);
              if (currentIdx < importSteps.length - 1) {
                setImportStep(importSteps[currentIdx + 1].key);
              }
              return;
            }
            
            try {
              if (importStep === 'myTeamHome') {
                console.log('Parsing Home Page:', text.substring(0, 200));
                const parsed = parseHomePage(text);
                console.log('Parsed result:', parsed);
                setMyTeamData(prev => ({ ...prev, ...parsed }));
              } else if (importStep === 'myTeamRoster') {
                console.log('📥 Importing MY TEAM roster...');
                let roster = parseRoster(text, myTeamData.roster);
                console.log('✅ Roster parsed, now loading career stats from localStorage...');
                // Auto-load career stats from localStorage
                roster = loadCareerStatsFromStorage(roster);
                console.log('✅ Career stats loaded, updating state...');
                setMyTeamData(prev => ({ ...prev, roster }));
              } else if (importStep === 'myTeamPlayerStats') {
                console.log('Processing player stats...');
                const updatedRoster = parsePlayerStats(text, myTeamData.roster);
                console.log('Updated roster:', updatedRoster);
                setMyTeamData(prev => ({ ...prev, roster: updatedRoster }));
              } else if (importStep === 'oppHome') {
                const parsed = parseHomePage(text);
                setOpponentData(prev => ({ ...prev, ...parsed }));
              } else if (importStep === 'oppRoster') {
                const roster = parseRoster(text, opponentData.roster);
                setOpponentData(prev => ({ ...prev, roster }));
              } else if (importStep === 'oppPlayerStats') {
                const updatedRoster = parsePlayerStats(text, opponentData.roster);
                setOpponentData(prev => ({ ...prev, roster: updatedRoster }));
              }
              
              setImportText('');
              
              const currentIdx = importSteps.findIndex(s => s.key === importStep);
              if (currentIdx < importSteps.length - 1) {
                setImportStep(importSteps[currentIdx + 1].key);
              } else {
                setShowImport(false);
              }
            } catch (error) {
              console.error('❌ Error in handleImport:', error);
              alert(`Error importing data: ${error.message}\nCheck console for details.`);
            }
          };

          const handleSkipStep = () => {
            // Save current data if any text was entered
            if (importText.trim()) {
              handleImport();
            } else {
              // Just move to next step if no data
              setImportText('');
              const currentIdx = importSteps.findIndex(s => s.key === importStep);
              if (currentIdx < importSteps.length - 1) {
                setImportStep(importSteps[currentIdx + 1].key);
              } else {
                setShowImport(false);
              }
            }
          };

            const handleBackStep = () => {
  // Save current data if any text was entered
  if (importText.trim()) {
    try {
      // Process the current step's data first
      if (importStep === 'myTeamHome') {
        const parsed = parseHomePage(importText);
        setMyTeamData(prev => ({ ...prev, ...parsed }));
      } else if (importStep === 'myTeamRoster') {
        let roster = parseRoster(importText, myTeamData.roster);
        roster = loadCareerStatsFromStorage(roster);
        setMyTeamData(prev => ({ ...prev, roster }));
      } else if (importStep === 'myTeamPlayerStats') {
        const updatedRoster = parsePlayerStats(importText, myTeamData.roster);
        setMyTeamData(prev => ({ ...prev, roster: updatedRoster }));
      } else if (importStep === 'oppHome') {
        const parsed = parseHomePage(importText);
        setOpponentData(prev => ({ ...prev, ...parsed }));
      } else if (importStep === 'oppRoster') {
        const roster = parseRoster(importText, opponentData.roster);
        setOpponentData(prev => ({ ...prev, roster }));
      } else if (importStep === 'oppPlayerStats') {
        const updatedRoster = parsePlayerStats(importText, opponentData.roster);
        setOpponentData(prev => ({ ...prev, roster: updatedRoster }));
      }
    } catch (error) {
      console.error('Error saving data on back:', error);
    }
  }
  
  // Then move to previous step
  setImportText('');
  const currentIdx = importSteps.findIndex(s => s.key === importStep);
  if (currentIdx > 0) {
    setImportStep(importSteps[currentIdx - 1].key);
  }
};

          const handleDragStart = (player, source, e) => {
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', null); // Required for Firefox
            setDraggedPlayer(player);
            setDragSource(source);
          };

          const handleDrop = (line, position, e) => {
            e.preventDefault();
            if (!draggedPlayer) return;

            const newLines = { ...lines };
            
            if (dragSource && dragSource.line) {
              newLines[dragSource.line][dragSource.position] = null;
            }

            const existingPlayer = newLines[line][position];
            newLines[line][position] = draggedPlayer;

            if (existingPlayer && dragSource && dragSource.line) {
              newLines[dragSource.line][dragSource.position] = existingPlayer;
            }

            setLines(newLines);
            setDraggedPlayer(null);
            setDragSource(null);
          };

          const handleLineColorChange = (line, color) => {
            setLines({ ...lines, [line]: { ...lines[line], color } });
          };

          const PlayerCard = ({ player, source, compact = false }) => {
            if (!player) return null;
            
            // Ensure stats object exists with defaults
            const stats = player.stats || { gp: 0, g: 0, a: 0, pts: 0, ppg: 0, ppa: 0, sh: 0, sha: 0, pim: 0, plusMinus: 0, fow: 0, fol: 0 };
            const careerStats = player.careerStats || { gp: 0, g: 0, a: 0, pts: 0, plusMinus: 0, faceoffPct: '0.0' };
            
            const isGoalie = player.position === 'G';
            const faceoffPct = stats.fow + stats.fol > 0 
              ? ((stats.fow / (stats.fow + stats.fol)) * 100).toFixed(1)
              : '0.0';
            
            // Convert grade to Sr./Jr./So./Fr. - dobYear
            const gradeYear = player.grade === 12 || player.grade === '12th' || player.grade === '12' ? 'Sr.' :
                             player.grade === 11 || player.grade === '11th' || player.grade === '11' ? 'Jr.' :
                             player.grade === 10 || player.grade === '10th' || player.grade === '10' ? 'So.' :
                             player.grade === 9 || player.grade === '9th' || player.grade === '9' ? 'Fr.' : 
                             player.grade;
            
            // Use imported DOB year (e.g., "2007")
            const gradeText = player.dobYear ? `${gradeYear} - ${player.dobYear}` : gradeYear;
            
            // Position text - for goalies, show "Left Catch" or "Right Catch"
            const positionText = isGoalie 
              ? `${player.shoots === 'L' ? 'Left' : 'Right'} Catch`
              : player.handed === 'L' ? 'Left' : player.handed === 'R' ? 'Right' : player.handed || '';
            
            return (
              <div
                draggable={true}
                onDragStart={(e) => handleDragStart(player, source, e)}
                className="bg-white border-2 border-gray-800 rounded p-1 hover:shadow-xl transition-all"
                style={{ minWidth: compact ? '130px' : '200px', fontFamily: 'Arial, sans-serif', cursor: 'grab' }}
              >
                <div className="flex gap-2">
                  {/* LEFT SIDE - Number and Pronunciation */}
                  <div className="flex flex-col items-center justify-start" style={{ width: '60px' }}>
                    <div className="text-6xl font-black leading-none" style={{ fontFamily: 'Arial Black, sans-serif' }}>
                      {player.number}
                    </div>
                    {player.pronunciation && (
                      <div className="italic text-center mt-0.5" style={{ fontSize: '8px', lineHeight: '1' }}>
                        "{player.pronunciation}"
                      </div>
                    )}
                  </div>
                  
                  {/* RIGHT SIDE - Player Info */}
                  <div className="flex-1" style={{ fontSize: '9px' }}>
                    <div className="font-bold text-sm leading-tight mb-0">{player.name}</div>
                    <div className="flex justify-between text-xs mb-0">
                      <span style={{ fontSize: '8px' }}>{positionText}</span>
                      <span style={{ fontSize: '8px' }}>{gradeText}</span>
                    </div>
                    <div className="flex justify-between mb-0" style={{ fontSize: '8px' }}>
                      <span>{stats.pim} PIM</span>
                      <span>+/- ({stats.plusMinus})</span>
                    </div>
                    
                    {!compact && !isGoalie && (
                      <>
                        <div className="font-bold text-right" style={{ fontSize: '8px', lineHeight: '1.1' }}>
                          25-26: {stats.gp}GP, {stats.g}-{stats.a}--{stats.pts}  +/- ({stats.plusMinus})
                        </div>
                        {stats.fow + stats.fol > 0 && (
                          <div className="font-bold text-right" style={{ fontSize: '8px', lineHeight: '1.1' }}>
                            Faceoffs {faceoffPct}%
                          </div>
                        )}
                        <div className="text-right" style={{ fontSize: '7px', lineHeight: '1.1' }}>
                          Career: {careerStats.gp}GP, {careerStats.g}-{careerStats.a}--{careerStats.pts}  +/- ({careerStats.plusMinus})
                        </div>
                        {careerStats.faceoffPct && careerStats.faceoffPct !== '0.0' && (
                          <div className="text-right" style={{ fontSize: '7px', lineHeight: '1.1' }}>
                            Faceoffs {careerStats.faceoffPct}%
                          </div>
                        )}
                      </>
                    )}
                    
                    {!compact && isGoalie && player.goalieStats && (
                      <>
                        <div className="font-bold text-right" style={{ fontSize: '8px', lineHeight: '1.1' }}>
                          25-26: {player.goalieStats.min}, {player.goalieStats.w}-{player.goalieStats.l}-{player.goalieStats.t} ({player.goalieStats.so} SO)
                        </div>
                        <div className="font-bold text-right" style={{ fontSize: '8px', lineHeight: '1.1' }}>
                          SV {player.goalieStats.sv}  GAA {player.goalieStats.gaa.toFixed(2)}  SV% {player.goalieStats.svp}
                        </div>
                        {player.careerGoalieStats && player.careerGoalieStats.gp > 0 && (
                          <>
                            <div className="text-right" style={{ fontSize: '7px', lineHeight: '1.1' }}>
                              Career: {player.careerGoalieStats.min}, {player.careerGoalieStats.w}-{player.careerGoalieStats.l}-{player.careerGoalieStats.t}
                            </div>
                            <div className="text-right" style={{ fontSize: '7px', lineHeight: '1.1' }}>
                              SV {player.careerGoalieStats.sv}  GAA {player.careerGoalieStats.gaa.toFixed(2)}  SV% {player.careerGoalieStats.svp}
                            </div>
                          </>
                        )}
                      </>
                    )}
                  </div>
                </div>
              </div>
            );
          };

          const LineSlot = ({ line, position, label }) => {
            const player = lines[line][position];
            
            return (
              <div
                onDragOver={(e) => e.preventDefault()}
                onDrop={(e) => handleDrop(line, position, e)}
                className="relative"
              >
                <div className="text-xs font-bold text-center mb-1">{label}</div>
                <div className={`border-2 border-dashed rounded p-2 min-h-[120px] flex items-center justify-center ${
                  player ? 'border-gray-400 bg-gray-50' : 'border-gray-300 bg-white'
                }`}>
                  {player ? (
                    <PlayerCard player={player} source={{ line, position }} compact={true} />
                  ) : (
                    <div className="text-gray-400 text-xs">Drop</div>
                  )}
                </div>
              </div>
            );
          };

          const getPlayersInLines = () => {
            const playersInLines = new Set();
            Object.values(lines).forEach(line => {
              Object.values(line).forEach(val => {
                if (val && typeof val === 'object' && val.id) {
                  playersInLines.add(val.id);
                }
              });
            });
            return playersInLines;
          };

          const availablePlayers = myTeamData.roster.filter(p => !getPlayersInLines().has(p.id));
          const currentStepInfo = importSteps.find(s => s.key === importStep);
          
          const normalizeFirstName = (name) => {
            const variations = {
              'joe': 'joseph', 'joseph': 'joe',
              'mike': 'michael', 'michael': 'mike',
              'dan': 'daniel', 'daniel': 'dan',
              'matt': 'matthew', 'matthew': 'matt',
              'rob': 'robert', 'robert': 'rob',
              'tom': 'thomas', 'thomas': 'tom',
              'jim': 'james', 'james': 'jim',
              'will': 'william', 'william': 'will',
              'chris': 'christopher', 'christopher': 'chris',
              'nick': 'nicholas', 'nicholas': 'nick'
            };
            const lower = name.toLowerCase();
            return variations[lower] ? [lower, variations[lower]] : [lower];
          };

          const handleCareerStatsImport = () => {
            try {
              // Combine all seasons into one import (they'll accumulate)
              const allSeasons = [
                careerStatsImport.lastSeason,
                careerStatsImport.twoSeasonsAgo,
                careerStatsImport.threeSeasonsAgo
              ].filter(s => s.trim());
              
              if (allSeasons.length === 0) {
                alert('Please paste at least one season of stats before importing.');
                return;
              }
              
              // Parse career stats directly into storage format (no roster needed!)
              const careerData = {};
              
              allSeasons.forEach((seasonText, seasonIdx) => {
                console.log(`📊 Processing season ${seasonIdx + 1}...`);
                const lines = seasonText.split('\n').map(l => l.trim()).filter(l => l);
                
                let inSkaterSection = false;
                let inGoalieSection = false;
                
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  
                  // Detect sections
                  if (line === 'Skater') {
                    inSkaterSection = true;
                    inGoalieSection = false;
                    continue;
                  }
                  if (line === 'Goalie') {
                    inSkaterSection = false;
                    inGoalieSection = true;
                    continue;
                  }
                  
                  // Skip headers
                  if (line === '#' || line === 'Name' || line === 'GP' || line.includes('AVG PTS')) continue;
                  
                  // Split by tabs
                  const fields = line.split('\t').filter(f => f.trim());
                  
                  // Need at least player number and name
                  if (fields.length < 3) continue;
                  
                  const number = fields[0];
                  const name = fields[1];
                  
                  // Must start with a digit
                  if (!/^\d+$/.test(number)) continue;
                  
                  // Extract last name and first initial
                  const nameParts = name.trim().split(/\s+/);
                  const firstInitial = nameParts[0]?.charAt(0)?.toUpperCase() || '';
                  const lastName = nameParts[nameParts.length - 1]?.toUpperCase() || '';
                  const key = `${lastName}_${firstInitial}`;
                  
                  if (inSkaterSection && fields.length >= 6) {
                    const seasonGP = parseInt(fields[2]) || 0;
                    const seasonG = parseInt(fields[3]) || 0;
                    const seasonA = parseInt(fields[4]) || 0;
                    const seasonPts = parseInt(fields[5]) || 0;
                    const seasonPlusMinus = parseInt(fields[19]) || 0;
                    const seasonFOW = parseInt(fields[14]) || 0;
                    const seasonFOL = parseInt(fields[15]) || 0;
                    
                    // Skip if this player already exists as a goalie (goalies can appear in skater section with 0 stats)
                    if (careerData[key]?.type === 'goalie') {
                      console.log(`⏭️ Skipping skater stats for ${name} - already saved as goalie`);
                      continue;
                    }
                    
                    // Accumulate across multiple seasons
                    if (!careerData[key]) {
                      careerData[key] = {
                        type: 'skater',
                        data: { gp: 0, g: 0, a: 0, pts: 0, plusMinus: 0, fow: 0, fol: 0 }
                      };
                    }
                    
                    careerData[key].data.gp += seasonGP;
                    careerData[key].data.g += seasonG;
                    careerData[key].data.a += seasonA;
                    careerData[key].data.pts += seasonPts;
                    careerData[key].data.plusMinus += seasonPlusMinus;
                    careerData[key].data.fow += seasonFOW;
                    careerData[key].data.fol += seasonFOL;
                    
                    console.log(`✅ Added skater career for ${name} (${key}):`, careerData[key].data);
                  } else if (inGoalieSection && fields.length >= 10) {
                    const seasonGP = parseInt(fields[2]) || 0;
                    const seasonMin = fields[3] || '0:00';
                    const seasonW = parseInt(fields[4]) || 0;
                    const seasonL = parseInt(fields[5]) || 0;
                    const seasonT = parseInt(fields[6]) || 0;
                    const seasonSO = parseInt(fields[12]) || 0;  // SO is field 12
                    const seasonGA = parseInt(fields[8]) || 0;
                    const seasonSV = parseInt(fields[9]) || 0;
                    
                    // GOALIE ALWAYS OVERWRITES SKATER - Convert any existing skater data to goalie
                    if (careerData[key]?.type === 'skater') {
                      console.log(`🔄 Converting ${name} from skater to goalie`);
                    }
                    
                    // Accumulate across multiple seasons (or initialize if first time OR converting from skater)
                    if (!careerData[key] || careerData[key].type !== 'goalie') {
                      careerData[key] = {
                        type: 'goalie',
                        data: { gp: 0, min: '0:00', w: 0, l: 0, t: 0, so: 0, ga: 0, sv: 0 }
                      };
                    }
                    
                    // Parse minutes safely
                    const seasonMinStr = seasonMin || '0:00';
                    const seasonMinParts = seasonMinStr.toString().split(':');
                    const minMinutes = parseInt(seasonMinParts[0]) || 0;
                    const minSeconds = parseInt(seasonMinParts[1]) || 0;
                    const totalSeasonSeconds = minMinutes * 60 + minSeconds;
                    
                    const existingMinStr = careerData[key].data.min || '0:00';
                    const existingMinParts = existingMinStr.toString().split(':');
                    const existingMinutes = parseInt(existingMinParts[0]) || 0;
                    const existingSeconds = parseInt(existingMinParts[1]) || 0;
                    const existingTotalSeconds = existingMinutes * 60 + existingSeconds;
                    
                    const newTotalSeconds = existingTotalSeconds + totalSeasonSeconds;
                    const newMinutes = Math.floor(newTotalSeconds / 60);
                    const newSeconds = newTotalSeconds % 60;
                    
                    careerData[key].data.gp += seasonGP;
                    careerData[key].data.min = `${newMinutes}:${String(newSeconds).padStart(2, '0')}`;
                    careerData[key].data.w += seasonW;
                    careerData[key].data.l += seasonL;
                    careerData[key].data.t += seasonT;
                    careerData[key].data.so += seasonSO;
                    careerData[key].data.ga += seasonGA;
                    careerData[key].data.sv += seasonSV;
                    
                    console.log(`✅ Added goalie career for ${name} (${key}):`, careerData[key].data);
                  }
                }
              });
              
              // Save directly to localStorage
              localStorage.setItem('hockey-scout-career-stats', JSON.stringify(careerData));
              console.log('💾 Saved career stats to localStorage:', Object.keys(careerData).length, 'players');
              console.log('💾 Career data keys:', Object.keys(careerData));
              
              alert(`✅ Successfully imported career stats for ${Object.keys(careerData).length} players!\n\n💾 Career stats saved to browser storage and will automatically load when you import your roster.`);
            } catch (error) {
              console.error('Career stats import error:', error);
              alert(`Error importing career stats: ${error.message}`);
            }
          };
          
          const totalCoachRecord = {
            w: (myTeamData.headCoach.careerRecord.w || 0) + myTeamData.record.w,
            l: (myTeamData.headCoach.careerRecord.l || 0) + myTeamData.record.l,
            t: (myTeamData.headCoach.careerRecord.t || 0) + myTeamData.record.t
          };
          
          const totalOppCoachRecord = {
            w: (opponentData.headCoach.careerRecord.w || 0) + opponentData.record.w,
            l: (opponentData.headCoach.careerRecord.l || 0) + opponentData.record.l,
            t: (opponentData.headCoach.careerRecord.t || 0) + opponentData.record.t
          };

          return (
            <div className="min-h-screen bg-gray-50">
              {showSetup && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                  <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
                    <div className="sticky top-0 bg-white border-b px-6 py-4 flex justify-between items-center">
                      <h2 className="text-xl font-bold">My Team Setup</h2>
                      <button onClick={() => setShowSetup(false)} className="text-gray-500 hover:text-gray-700">
                        <X size={24} />
                      </button>
                    </div>
                    
                    <div className="p-6 space-y-4">
                      <div>
                        <label className="block text-sm font-semibold mb-1">Team Name</label>
                        <input
                          type="text"
                          value={myTeamSetup.teamName}
                          onChange={(e) => setMyTeamSetup({...myTeamSetup, teamName: e.target.value})}
                          className="w-full border rounded px-3 py-2"
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-semibold mb-1">Arena</label>
                        <input
                          type="text"
                          value={myTeamSetup.arena}
                          onChange={(e) => setMyTeamSetup({...myTeamSetup, arena: e.target.value})}
                          className="w-full border rounded px-3 py-2"
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-semibold mb-2">Team Logo</label>
                        <div className="flex gap-2 items-center">
                          {myTeamSetup.logo && (
                            <img src={myTeamSetup.logo} alt="Logo" className="h-16 w-16 object-contain border rounded" />
                          )}
                          <div className="flex-1">
                            <input
                              type="file"
                              accept="image/*"
                              onChange={(e) => handleLogoUpload(e, true, true)}
                              className="text-sm"
                            />
                            <button
                              onClick={() => handleLogoPaste(true, true)}
                              className="mt-2 bg-blue-500 text-white px-3 py-1 rounded text-sm hover:bg-blue-600"
                            >
                              Paste from Clipboard
                            </button>
                          </div>
                        </div>
                      </div>
                      
                      <div className="grid grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm font-semibold mb-1">Primary Color</label>
                          <input
                            type="color"
                            value={myTeamSetup.colors.primary}
                            onChange={(e) => setMyTeamSetup({...myTeamSetup, colors: {...myTeamSetup.colors, primary: e.target.value}})}
                            className="w-full h-10 border rounded cursor-pointer"
                          />
                        </div>
                        <div>
                          <label className="block text-sm font-semibold mb-1">Secondary Color</label>
                          <input
                            type="color"
                            value={myTeamSetup.colors.secondary}
                            onChange={(e) => setMyTeamSetup({...myTeamSetup, colors: {...myTeamSetup.colors, secondary: e.target.value}})}
                            className="w-full h-10 border rounded cursor-pointer"
                          />
                        </div>
                      </div>
                    </div>
                    
                    {/* Career Stats Import Section */}
                    <div className="bg-blue-50 p-4 rounded">
                      <h3 className="font-bold mb-2">Career Stats Import</h3>
                      <p className="text-sm mb-3 text-gray-600">Paste previous seasons' stats from Legacy Player Stats page to show career totals on player cards.</p>
                      
                      <div className="space-y-3">
                        <div>
                          <label className="block text-sm font-semibold mb-1">Last Season Legacy Final Player Stats</label>
                          <textarea
                            value={careerStatsImport.lastSeason}
                            onChange={(e) => setCareerStatsImport({...careerStatsImport, lastSeason: e.target.value})}
                            placeholder="Paste player stats from last season..."
                            className="w-full border rounded px-3 py-2 font-mono text-xs"
                            rows="3"
                          />
                        </div>
                        
                        <div>
                          <label className="block text-sm font-semibold mb-1">2 Seasons Ago Legacy Final Player Stats</label>
                          <textarea
                            value={careerStatsImport.twoSeasonsAgo}
                            onChange={(e) => setCareerStatsImport({...careerStatsImport, twoSeasonsAgo: e.target.value})}
                            placeholder="Paste player stats from 2 seasons ago..."
                            className="w-full border rounded px-3 py-2 font-mono text-xs"
                            rows="3"
                          />
                        </div>
                        
                        <div>
                          <label className="block text-sm font-semibold mb-1">3 Seasons Ago Legacy Final Player Stats</label>
                          <textarea
                            value={careerStatsImport.threeSeasonsAgo}
                            onChange={(e) => setCareerStatsImport({...careerStatsImport, threeSeasonsAgo: e.target.value})}
                            placeholder="Paste player stats from 3 seasons ago..."
                            className="w-full border rounded px-3 py-2 font-mono text-xs"
                            rows="3"
                          />
                        </div>
                        
                        <button
                          onClick={handleCareerStatsImport}
                          className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 text-sm w-full"
                        >
                          Import & Match Career Stats
                        </button>
                      </div>
                    </div>
                    
                    {/* Pronunciation Guide Section */}
                    <div className="bg-purple-50 p-4 rounded mt-4">
                      <h3 className="font-bold mb-2">Player Name Pronunciation Guide</h3>
                      <p className="text-sm mb-3 text-gray-600">Add phonetic pronunciations for player last names (saved for future use)</p>
                      
                      <div className="space-y-2 max-h-40 overflow-y-auto">
                        {myTeamData.roster.map((player) => (
                          <div key={player.id} className="flex items-center gap-2">
                            <span className="text-sm font-semibold w-40">#{player.number} {player.lastName}:</span>
                            <input
                              type="text"
                              value={myTeamSetup.pronunciations[player.lastName] || ''}
                              onChange={(e) => {
                                setMyTeamSetup({
                                  ...myTeamSetup, 
                                  pronunciations: {
                                    ...myTeamSetup.pronunciations,
                                    [player.lastName]: e.target.value
                                  }
                                });
                              }}
                              placeholder='e.g., "HOLL-a-nehn"'
                              className="flex-1 border rounded px-2 py-1 text-sm"
                            />
                          </div>
                        ))}
                      </div>
                      <p className="text-xs text-gray-500 mt-2">💡 Pronunciations are saved by last name and will auto-apply to future rosters</p>
                    </div>
                    
                    <div className="border-t px-6 py-4 flex justify-end">
                      <button
                        onClick={() => setShowSetup(false)}
                        className="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700"
                      >
                        Save & Close
                      </button>
                    </div>
                  </div>
                </div>
              )}

              {showImport && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                  <div className="bg-white rounded-lg shadow-xl max-w-3xl w-full max-h-[90vh] overflow-y-auto">
                    <div className="sticky top-0 bg-white border-b px-6 py-4 flex justify-between items-center">
                      <div>
                        <h2 className="text-xl font-bold">Import Data</h2>
                        <p className="text-sm text-gray-600 mt-1">{currentStepInfo?.label}</p>
                      </div>
                      <button onClick={() => setShowImport(false)} className="text-gray-500 hover:text-gray-700">
                        <X size={24} />
                      </button>
                    </div>
                    
                    <div className="p-6">
                      <div className="mb-4 flex gap-1 flex-wrap">
                        {importSteps.map((step, idx) => (
                          <div
                            key={step.key}
                            className={`text-xs px-2 py-1 rounded ${
                              step.key === importStep 
                                ? 'bg-blue-600 text-white' 
                                : 'bg-gray-200 text-gray-600'
                            }`}
                          >
                            {idx + 1}. {step.label}
                          </div>
                        ))}
                      </div>
                      
                      {currentStepInfo?.isLogo ? (
                        <div className="space-y-4">
                          <p className="text-sm">Upload or paste the opponent's logo</p>
                          <div className="flex gap-2 items-center">
                            {opponentLogo && (
                              <img src={opponentLogo} alt="Opponent Logo" className="h-20 w-20 object-contain border rounded" />
                            )}
                            <div>
                              <input
                                type="file"
                                accept="image/*"
                                onChange={(e) => handleLogoUpload(e, false, false)}
                                className="text-sm mb-2"
                              />
                              <button
                                onClick={() => handleLogoPaste(false, false)}
                                className="bg-blue-500 text-white px-3 py-1 rounded text-sm hover:bg-blue-600 block"
                              >
                                Paste from Clipboard
                              </button>
                            </div>
                          </div>
                        </div>
                      ) : isSpreadsheetStep(importStep) ? (
                        <div>
                          <label className="block text-sm font-semibold mb-2">
                            Paste player stats from Legacy Hockey
                          </label>
                          <p className="text-xs text-gray-600 mb-3">
                            Go to Player Stats page → Select all (Ctrl+A) → Copy (Ctrl+C) → Paste below (Ctrl+V)
                          </p>
                          <textarea
                            value={importText}
                            onChange={(e) => {
                              setImportText(e.target.value);
                              if (e.target.value) handleSpreadsheetPaste(e.target.value);
                            }}
                            placeholder="Paste player stats table here..."
                            className="w-full border rounded px-3 py-2 font-mono text-xs mb-3"
                            rows="3"
                          />
                          
                          {spreadsheetData.length > 0 && (
                            <div className="border rounded overflow-auto" style={{ maxHeight: '400px' }}>
                              <table className="w-full text-xs">
                                <thead className="bg-gray-100 sticky top-0">
                                  <tr>
                                    {spreadsheetHeaders.map((header, idx) => (
                                      <th key={idx} className="border px-2 py-1 text-left font-semibold">
                                        {header}
                                      </th>
                                    ))}
                                  </tr>
                                </thead>
                                <tbody>
                                  {spreadsheetData.map((row, rowIdx) => (
                                    <tr key={rowIdx} className={rowIdx % 2 === 0 ? 'bg-white' : 'bg-gray-50'}>
                                      {row.map((cell, cellIdx) => (
                                        <td key={cellIdx} className="border px-2 py-1">
                                          {cell}
                                        </td>
                                      ))}
                                    </tr>
                                  ))}
                                </tbody>
                              </table>
                            </div>
                          )}
                        </div>
                      ) : (
                        <div>
                          <label className="block text-sm font-semibold mb-2">
                            Paste content from {currentStepInfo?.label}
                          </label>
                          <textarea
                            value={importText}
                            onChange={(e) => setImportText(e.target.value)}
                            placeholder="Paste text here..."
                            className="w-full border rounded px-3 py-2 font-mono text-xs"
                            rows="12"
                          />
                        </div>
                      )}
                    </div>
                    
                    <div className="border-t px-6 py-4 flex justify-between">
  <div className="flex gap-2">
    {importSteps.findIndex(s => s.key === importStep) > 0 && (
      <button
        onClick={handleBackStep}
        className="bg-gray-400 text-white px-4 py-2 rounded hover:bg-gray-500"
      >
        Back
      </button>
    )}
    <button
      onClick={handleSkipStep}
      className="bg-gray-400 text-white px-4 py-2 rounded hover:bg-gray-500"
    >
      Skip Step
    </button>
  </div>
  <button
    onClick={handleImport}
    className="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700"
  >
    {importSteps.findIndex(s => s.key === importStep) === importSteps.length - 1 ? 'Finish' : 'Next Step'}
  </button>
</div>
                  </div>
                </div>
              )}

              {showColorPicker && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                  <div className="bg-white rounded-lg shadow-xl max-w-md w-full">
                    <div className="border-b px-6 py-4 flex justify-between items-center">
                      <h2 className="text-xl font-bold">Opponent Colors</h2>
                      <button onClick={() => setShowColorPicker(false)} className="text-gray-500 hover:text-gray-700">
                        <X size={24} />
                      </button>
                    </div>
                    
                    <div className="p-6 space-y-4">
                      <div>
                        <label className="block text-sm font-semibold mb-1">Primary Color</label>
                        <input
                          type="color"
                          value={opponentColors.primary}
                          onChange={(e) => setOpponentColors({...opponentColors, primary: e.target.value})}
                          className="w-full h-12 border rounded cursor-pointer"
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-semibold mb-1">Secondary Color</label>
                        <input
                          type="color"
                          value={opponentColors.secondary}
                          onChange={(e) => setOpponentColors({...opponentColors, secondary: e.target.value})}
                          className="w-full h-12 border rounded cursor-pointer"
                        />
                      </div>
                    </div>
                    
                    <div className="border-t px-6 py-4 flex justify-end">
                      <button
                        onClick={() => setShowColorPicker(false)}
                        className="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700"
                      >
                        Done
                      </button>
                    </div>
                  </div>
                </div>
              )}

              <div className="no-print bg-gradient-to-r from-blue-900 to-blue-700 text-white p-3 shadow-lg sticky top-0 z-50">
                <div className="max-w-7xl mx-auto flex justify-between items-center">
                  <div className="flex items-center gap-3">
                    {myTeamSetup.logo && (
                      <img src={myTeamSetup.logo} alt="Team" className="h-10 w-10 object-contain bg-white rounded-full p-1" />
                    )}
                    <h1 className="text-xl font-bold">MSHSL Game </h1>
                  </div>
                  <div className="flex gap-2">
                    <button onClick={() => setShowSetup(true)} className="bg-white text-blue-900 px-3 py-1.5 rounded hover:bg-gray-100 flex items-center gap-1 text-sm font-semibold">
                      <Settings size={16} /> My Team Setup
                    </button>
                    <button onClick={() => setShowImport(true)} className="bg-white text-blue-900 px-3 py-1.5 rounded hover:bg-gray-100 flex items-center gap-1 text-sm font-semibold">
                      <Upload size={16} /> Import Data
                    </button>
                    <button onClick={() => setShowColorPicker(!showColorPicker)} className="bg-white text-blue-900 px-3 py-1.5 rounded hover:bg-gray-100 text-sm font-semibold">
                      🎨 Colors
                    </button>
                    <button onClick={() => window.print()} className="bg-green-600 text-white px-3 py-1.5 rounded hover:bg-green-700 flex items-center gap-1 text-sm font-semibold">
                      <Printer size={16} /> Print
                    </button>
                  </div>
                </div>
              </div>

              <div className="print-page-1 bg-white p-1 max-w-7xl mx-auto">
                {/* New 3-Column Header */}
                <div className="rounded-lg overflow-hidden mb-1" style={{ 
                  background: `linear-gradient(to right, ${myTeamSetup.colors.primary}15 0%, white 40%, white 60%, ${opponentColors.primary}15 100%)`,
                  border: `2px solid black`
                }}>
                  <div className="grid grid-cols-[30%_40%_30%] gap-0 p-2">
                    {/* LEFT COLUMN - MY TEAM (30%) */}
                    <div className="flex flex-col items-center text-center space-y-1">
                      {/* Logo */}
                      {myTeamSetup.logo && (
                        <img src={myTeamSetup.logo} alt="Team" className="h-12 w-12 object-contain" style={{ border: `2px solid ${myTeamSetup.colors.primary}` }} />
                      )}
                      
                      {/* Head Coach */}
                      <div>
                        <div style={{ fontSize: '8px' }} className="font-semibold text-gray-600">Head Coach</div>
                        <div style={{ fontSize: '10px' }} className="font-bold">{myTeamData.headCoach.name}</div>
                        <div style={{ fontSize: '7px' }} className="text-gray-600">(Career: {totalCoachRecord.w}-{totalCoachRecord.l}-{totalCoachRecord.t})</div>
                      </div>
                      
                      {/* Last Game */}
                      <div className="w-full">
                        <div style={{ fontSize: '8px' }} className="font-semibold text-gray-600 uppercase mb-0">Last Game</div>
                        {myTeamData.lastGame ? (
                          <>
                            <div style={{ fontSize: '9px' }} className="font-bold">
                              {myTeamData.teamName} <span className={`font-black ${
                                myTeamData.lastGame.result === 'W' ? 'text-green-600' :
                                myTeamData.lastGame.result === 'L' ? 'text-red-600' :
                                'text-gray-600'
                              }`}>{myTeamData.lastGame.ourScore} - {myTeamData.lastGame.oppScore}</span> {myTeamData.lastGame.opponent}
                            </div>
                            <div style={{ fontSize: '7px' }} className="text-gray-500">{myTeamData.lastGame.date}</div>
                          </>
                        ) : (
                          <div style={{ fontSize: '9px' }} className="text-gray-400">N/A</div>
                        )}
                      </div>
                      
                      {/* Next Game */}
                      <div className="w-full">
                        <div style={{ fontSize: '8px' }} className="font-semibold text-gray-600 uppercase mb-0">Next Game</div>
                        {myTeamData.nextGame ? (
                          <>
                            <div style={{ fontSize: '9px' }} className="font-bold">{myTeamData.nextGame.isHome ? 'VS' : 'AT'} {myTeamData.nextGame.opponent || 'TBD'}</div>
                            <div style={{ fontSize: '7px' }} className="text-gray-500">{myTeamData.nextGame.date} @ {myTeamData.nextGame.time}</div>
                          </>
                        ) : (
                          <div style={{ fontSize: '9px' }} className="text-gray-400">TBD</div>
                        )}
                      </div>
                      
                      {/* Stats Row - 4 boxes horizontal */}
                      <div className="flex gap-1 w-full justify-center">
                        <div className="bg-white border border-gray-300 rounded p-1 flex-1" style={{ minWidth: '50px' }}>
                          <div style={{ fontSize: '7px' }} className="font-semibold text-gray-700">Power Play</div>
                          <div style={{ fontSize: '12px' }} className="font-bold" style={{ color: myTeamSetup.colors.primary }}>{myTeamData.stats.ppPct}%</div>
                        </div>
                        <div className="bg-white border border-gray-300 rounded p-1 flex-1" style={{ minWidth: '50px' }}>
                          <div style={{ fontSize: '7px' }} className="font-semibold text-gray-700">Penalty Kill</div>
                          <div style={{ fontSize: '12px' }} className="font-bold" style={{ color: myTeamSetup.colors.primary }}>{myTeamData.stats.pkPct}%</div>
                        </div>
                        <div className="bg-white border border-gray-300 rounded p-1 flex-1" style={{ minWidth: '50px' }}>
                          <div style={{ fontSize: '7px' }} className="font-semibold text-gray-700">Goals/Game</div>
                          <div className="text-lg font-bold" style={{ color: myTeamSetup.colors.primary }}>{myTeamData.stats.gpg.toFixed(2)}</div>
                        </div>
                        <div className="bg-white border border-gray-300 rounded p-2 flex-1 min-w-[70px]">
                          <div className="text-xs font-semibold text-gray-700">GA/Game</div>
                          <div className="text-lg font-bold" style={{ color: myTeamSetup.colors.primary }}>{myTeamData.stats.gapg.toFixed(2)}</div>
                        </div>
                      </div>
                    </div>
                    
                    {/* CENTER COLUMN - MATCHUP (40%) */}
                    <div className="flex flex-col items-center justify-center text-center space-y-2 px-4">
                      {/* Hand-written notes grid - Two separate grids side by side */}
                      <div className="w-full flex gap-4 justify-center">
                        {/* Left grid: 3 columns x 4 rows */}
                        <div className="grid grid-cols-3 gap-0" style={{ 
                          border: '1px solid #e5e7eb',
                          width: '60px',
                          height: '60px'
                        }}>
                          {[...Array(12)].map((_, i) => (
                            <div key={i} style={{
                              border: '1px solid #e5e7eb',
                              borderTop: i < 3 ? 'none' : '1px solid #e5e7eb',
                              borderLeft: i % 3 === 0 ? 'none' : '1px solid #e5e7eb',
                              borderRight: i % 3 === 2 ? 'none' : '1px solid #e5e7eb',
                              borderBottom: i >= 9 ? 'none' : '1px solid #e5e7eb'
                            }}></div>
                          ))}
                        </div>
                        
                        {/* Right grid: 2 columns x 4 rows with G labels in bottom row */}
                        <div className="grid grid-cols-2 gap-0" style={{ 
                          border: '1px solid #e5e7eb',
                          width: '40px',
                          height: '60px'
                        }}>
                          {[...Array(8)].map((_, i) => (
                            <div key={i} style={{
                              border: '1px solid #e5e7eb',
                              borderTop: i < 2 ? 'none' : '1px solid #e5e7eb',
                              borderLeft: i % 2 === 0 ? 'none' : '1px solid #e5e7eb',
                              borderRight: i % 2 === 1 ? 'none' : '1px solid #e5e7eb',
                              borderBottom: i >= 6 ? 'none' : '1px solid #e5e7eb',
                              display: 'flex',
                              alignItems: 'center',
                              justifyContent: 'center',
                              fontSize: '8px',
                              fontWeight: 'bold',
                              color: '#666'
                            }}>
                              {''}
                            </div>
                          ))}
                        </div>
                      </div>
                      
                      {/* My Team */}
                      <div style={{ fontSize: '16px', color: myTeamSetup.colors.primary }} className="font-black leading-tight">
                        {myTeamSetup.teamName} {myTeamSetup.mascot ? myTeamSetup.mascot : ''}
                      </div>
                      <div style={{ fontSize: '8px' }} className="text-gray-700">
                        ({myTeamData.record.w}-{myTeamData.record.l}-{myTeamData.record.t}, {myTeamData.section}, {myTeamData.conference})
                      </div>
                      
                      <div style={{ fontSize: '10px' }} className="font-semibold text-gray-600">vs</div>
                      
                      {/* Opponent */}
                      <div style={{ fontSize: '16px', color: opponentColors.primary }} className="font-black leading-tight">
                        {opponentData.teamName} {opponentData.nickname ? opponentData.nickname : ''}
                      </div>
                      <div style={{ fontSize: '8px' }} className="text-gray-700">
                        {opponentData.record.w ? `(${opponentData.record.w}-${opponentData.record.l}-${opponentData.record.t}, ${opponentData.section}, ${opponentData.conference})` : ''}
                      </div>
                      
                      {/* Location */}
                      {myTeamData.nextGame?.location && (
                        <div style={{ fontSize: '7px' }} className="text-gray-500">{ myTeamData.nextGame.location}</div>
                      )}
                      
                      {/* Game # at bottom */}
                      <div style={{ fontSize: '10px' }} className="font-semibold text-gray-600">Game #{myTeamData.nextGame?.gameNum || (myTeamData.record.w + myTeamData.record.l + myTeamData.record.t + 1)}</div>
                    </div>
                    
                    {/* RIGHT COLUMN - OPPONENT (30%) */}
                    <div className="flex flex-col items-center text-center space-y-1">
                      {/* Logo */}
                      {opponentLogo && (
                        <img src={opponentLogo} alt="Opponent" className="h-12 w-12 object-contain" style={{ border: `2px solid ${opponentColors.primary}` }} />
                      )}
                      
                      {/* Head Coach */}
                      <div>
                        <div style={{ fontSize: '8px' }} className="font-semibold text-gray-600">Head Coach</div>
                        <div style={{ fontSize: '10px' }} className="font-bold">{opponentData.headCoach.name}</div>
                        <div style={{ fontSize: '7px' }} className="text-gray-600">(Career: {totalOppCoachRecord.w}-{totalOppCoachRecord.l}-{totalOppCoachRecord.t})</div>
                      </div>
                      
                      {/* Last Game */}
                      <div className="w-full">
                        <div style={{ fontSize: '8px' }} className="font-semibold text-gray-600 uppercase mb-0">Last Game</div>
                        {opponentData.lastGame ? (
                          <>
                            <div style={{ fontSize: '9px' }} className="font-bold">
                              {opponentData.teamName} <span className={`font-black ${
                                opponentData.lastGame.result === 'W' ? 'text-green-600' :
                                opponentData.lastGame.result === 'L' ? 'text-red-600' :
                                'text-gray-600'
                              }`}>{opponentData.lastGame.ourScore} - {opponentData.lastGame.oppScore}</span> {opponentData.lastGame.opponent}
                            </div>
                            <div style={{ fontSize: '7px' }} className="text-gray-500">{opponentData.lastGame.date}</div>
                          </>
                        ) : (
                          <div style={{ fontSize: '9px' }} className="text-gray-400">N/A</div>
                        )}
                      </div>
                      
                      {/* Next Game */}
                      <div className="w-full">
                        <div style={{ fontSize: '8px' }} className="font-semibold text-gray-600 uppercase mb-0">Next Game</div>
                        {opponentData.nextGame ? (
                          <>
                            <div style={{ fontSize: '9px' }} className="font-bold">{opponentData.nextGame.isHome ? 'VS' : 'AT'} {opponentData.nextGame.opponent || 'TBD'}</div>
                            <div style={{ fontSize: '7px' }} className="text-gray-500">{opponentData.nextGame.date} @ {opponentData.nextGame.time}</div>
                          </>
                        ) : (
                          <div style={{ fontSize: '9px' }} className="text-gray-400">TBD</div>
                        )}
                      </div>
                      
                      {/* Stats Row - 4 boxes horizontal */}
                      <div className="flex gap-1 w-full justify-center">
                        <div className="bg-white border border-gray-300 rounded p-1 flex-1" style={{ minWidth: '50px' }}>
                          <div style={{ fontSize: '7px' }} className="font-semibold text-gray-700">Power Play</div>
                          <div style={{ fontSize: '12px' }} className="font-bold" style={{ color: opponentColors.primary }}>{opponentData.stats.ppPct}%</div>
                        </div>
                        <div className="bg-white border border-gray-300 rounded p-1 flex-1" style={{ minWidth: '50px' }}>
                          <div style={{ fontSize: '7px' }} className="font-semibold text-gray-700">Penalty Kill</div>
                          <div style={{ fontSize: '12px' }} className="font-bold" style={{ color: opponentColors.primary }}>{opponentData.stats.pkPct}%</div>
                        </div>
                        <div className="bg-white border border-gray-300 rounded p-1 flex-1" style={{ minWidth: '50px' }}>
                          <div style={{ fontSize: '7px' }} className="font-semibold text-gray-700">Goals/Game</div>
                          <div style={{ fontSize: '12px' }} className="font-bold" style={{ color: opponentColors.primary }}>{opponentData.stats.gpg.toFixed(2)}</div>
                        </div>
                        <div className="bg-white border border-gray-300 rounded p-1 flex-1" style={{ minWidth: '50px' }}>
                          <div style={{ fontSize: '7px' }} className="font-semibold text-gray-700">GA/Game</div>
                          <div style={{ fontSize: '12px' }} className="font-bold" style={{ color: opponentColors.primary }}>{opponentData.stats.gapg.toFixed(2)}</div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="no-print bg-gray-100 rounded p-2 mb-3">
                  <h2 className="text-sm font-bold mb-2">Available Players ({availablePlayers.length})</h2>
                  <div className="grid grid-cols-5 gap-2">
                    {availablePlayers.map(player => (
                      <PlayerCard key={player.id} player={player} source={{ roster: true }} />
                    ))}
                  </div>
                </div>

                <div className="mb-3">
                  <h2 style={{ fontSize: '14px' }} className="font-bold mb-1">FORWARD LINES</h2>
                  {['line1', 'line2', 'line3', 'line4'].map((line, idx) => (
                    <div key={line} className={`mb-1 rounded p-1 border-2 ${colorClasses[lines[line].color]}`}>
                      <div className="flex items-center gap-2 mb-0">
                        <select
                          value={lines[line].color}
                          onChange={(e) => handleLineColorChange(line, e.target.value)}
                          className="no-print text-xs border rounded px-1"
                        >
                          {colorOptions.map(c => <option key={c} value={c}>{c}</option>)}
                        </select>
                        <div className="flex-1 grid grid-cols-3 gap-1">
                          <LineSlot line={line} position="lw" label="LW" />
                          <LineSlot line={line} position="c" label="C" />
                          <LineSlot line={line} position="rw" label="RW" />
                        </div>
                      </div>
                    </div>
                  ))}
                </div>

                <div className="grid grid-cols-2 gap-2">
                  <div>
                    <h2 style={{ fontSize: '14px' }} className="font-bold mb-1">DEFENSE PAIRS</h2>
                    {['d1', 'd2', 'd3'].map((line, idx) => (
                      <div key={line} className="mb-1 bg-gray-100 rounded p-1">
                        <div className="grid grid-cols-2 gap-1">
                          <LineSlot line={line} position="ld" label="LD" />
                          <LineSlot line={line} position="rd" label="RD" />
                        </div>
                      </div>
                    ))}
                  </div>

                  <div>
                    <h2 style={{ fontSize: '14px' }} className="font-bold mb-1">GOALIES</h2>
                    <div className="space-y-1 mb-2">
                      <LineSlot line="goalies" position="starter" label="Starter" />
                      <LineSlot line="goalies" position="backup" label="Backup" />
                    </div>

                    <div className="bg-yellow-50 border-2 border-yellow-400 rounded p-1 mt-2">
                      <h3 style={{ fontSize: '11px' }} className="font-bold mb-1">Student Manager</h3>
                      <input
                        type="text"
                        value={myTeamData.studentManager}
                        onChange={(e) => setMyTeamData({...myTeamData, studentManager: e.target.value})}
                        placeholder="Name"
                        className="w-full border rounded px-1 py-0.5 text-xs"
                      />
                    </div>

                    <div className="bg-red-50 border-2 border-red-400 rounded p-1 mt-1">
                      <h3 style={{ fontSize: '11px' }} className="font-bold mb-1">Injured/Illness</h3>
                      <textarea
                        value={myTeamData.injuries.join('\n')}
                        onChange={(e) => setMyTeamData({...myTeamData, injuries: e.target.value.split('\n')})}
                        placeholder="Player names (one per line)"
                        className="w-full border rounded px-2 py-1 text-sm"
                        rows="2"
                      />
                    </div>
                  </div>
                </div>

                <div className="grid grid-cols-2 gap-1 mt-1">
                  <div className="border-2 rounded p-1" style={{ borderColor: myTeamSetup.colors.primary, background: `${myTeamSetup.colors.primary}10` }}>
                    <h3 style={{ fontSize: '10px' }} className="font-bold mb-0">Tigers PK</h3>
                    <textarea
                      value={coachNotes.pk}
                      onChange={(e) => setCoachNotes({...coachNotes, pk: e.target.value})}
                      placeholder="PK notes..."
                      className="w-full border rounded px-1 py-0.5"
                      style={{ fontSize: '8px' }}
                      rows="2"
                    />
                  </div>
                  <div className="border-2 rounded p-1" style={{ borderColor: myTeamSetup.colors.primary, background: `${myTeamSetup.colors.primary}10` }}>
                    <h3 style={{ fontSize: '10px' }} className="font-bold mb-0">Tigers PP</h3>
                    <textarea
                      value={coachNotes.pp}
                      onChange={(e) => setCoachNotes({...coachNotes, pp: e.target.value})}
                      placeholder="PP notes..."
                      className="w-full border rounded px-1 py-0.5"
                      style={{ fontSize: '8px' }}
                      rows="2"
                    />
                  </div>
                </div>
              </div>

              <div className="print-page-2 bg-white p-4 max-w-7xl mx-auto page-break">
                <div className="rounded-lg p-3 mb-3" style={{ border: `3px solid ${opponentColors.primary}` }}>
                  <h2 className="text-2xl font-black text-center mb-1" style={{ color: opponentColors.primary }}>
                    Opponent: {opponentData.teamName} {opponentData.nickname}
                  </h2>
                  <div className="text-center text-sm font-semibold">
                    Record: {opponentData.record.w}-{opponentData.record.l}-{opponentData.record.t}
                  </div>
                </div>

                <div className="mb-3">
                  <h2 className="text-xl font-bold mb-2" style={{ color: opponentColors.primary }}>Opponent Roster</h2>
                  
                  <div className="mb-2">
                    <h3 className="font-bold mb-1 px-2 py-1 rounded text-sm" style={{ background: `${opponentColors.primary}20`, color: opponentColors.secondary }}>Forwards</h3>
                    <table className="w-full text-xs border-collapse">
                      <thead>
                        <tr className="bg-gray-200">
                          <th className="border p-1">#</th>
                          <th className="border p-1 text-left">Name</th>
                          <th className="border p-1">Gr</th>
                          <th className="border p-1">GP</th>
                          <th className="border p-1">G</th>
                          <th className="border p-1">A</th>
                          <th className="border p-1">PTS</th>
                          <th className="border p-1">PPG</th>
                          <th className="border p-1">PPA</th>
                          <th className="border p-1">SH</th>
                          <th className="border p-1">SHA</th>
                          <th className="border p-1">PIM</th>
                        </tr>
                      </thead>
                      <tbody>
                        {opponentData.roster
                          .filter(p => p.position === 'F')
                          .sort((a, b) => parseInt(a.number) - parseInt(b.number))
                          .map(player => (
                            <tr key={player.id}>
                              <td className="border p-1 font-bold text-center">{player.number}</td>
                              <td className="border p-1">{player.firstName} {player.lastName}</td>
                              <td className="border p-1 text-center">{player.grade}</td>
                              <td className="border p-1 text-center">{player.stats.gp}</td>
                              <td className="border p-1 text-center">{player.stats.g}</td>
                              <td className="border p-1 text-center">{player.stats.a}</td>
                              <td className="border p-1 text-center font-bold">{player.stats.pts}</td>
                              <td className="border p-1 text-center">{player.stats.ppg}</td>
                              <td className="border p-1 text-center">{player.stats.ppa}</td>
                              <td className="border p-1 text-center">{player.stats.sh}</td>
                              <td className="border p-1 text-center">{player.stats.sha}</td>
                              <td className="border p-1 text-center">{player.stats.pim}</td>
                            </tr>
                          ))}
                      </tbody>
                    </table>
                  </div>

                  <div className="mb-2">
                    <h3 className="font-bold mb-1 px-2 py-1 rounded text-sm" style={{ background: `${opponentColors.primary}20`, color: opponentColors.secondary }}>Defense</h3>
                    <table className="w-full text-xs border-collapse">
                      <thead>
                        <tr className="bg-gray-200">
                          <th className="border p-1">#</th>
                          <th className="border p-1 text-left">Name</th>
                          <th className="border p-1">Gr</th>
                          <th className="border p-1">GP</th>
                          <th className="border p-1">G</th>
                          <th className="border p-1">A</th>
                          <th className="border p-1">PTS</th>
                          <th className="border p-1">PPG</th>
                          <th className="border p-1">PPA</th>
                          <th className="border p-1">SH</th>
                          <th className="border p-1">SHA</th>
                          <th className="border p-1">PIM</th>
                        </tr>
                      </thead>
                      <tbody>
                        {opponentData.roster
                          .filter(p => p.position === 'D')
                          .sort((a, b) => parseInt(a.number) - parseInt(b.number))
                          .map(player => (
                            <tr key={player.id}>
                              <td className="border p-1 font-bold text-center">{player.number}</td>
                              <td className="border p-1">{player.firstName} {player.lastName}</td>
                              <td className="border p-1 text-center">{player.grade}</td>
                              <td className="border p-1 text-center">{player.stats.gp}</td>
                              <td className="border p-1 text-center">{player.stats.g}</td>
                              <td className="border p-1 text-center">{player.stats.a}</td>
                              <td className="border p-1 text-center font-bold">{player.stats.pts}</td>
                              <td className="border p-1 text-center">{player.stats.ppg}</td>
                              <td className="border p-1 text-center">{player.stats.ppa}</td>
                              <td className="border p-1 text-center">{player.stats.sh}</td>
                              <td className="border p-1 text-center">{player.stats.sha}</td>
                              <td className="border p-1 text-center">{player.stats.pim}</td>
                            </tr>
                          ))}
                      </tbody>
                    </table>
                  </div>

                  <div className="mb-2">
                    <h3 className="font-bold mb-1 px-2 py-1 rounded text-sm" style={{ background: `${opponentColors.primary}20`, color: opponentColors.secondary }}>Goalies</h3>
                    <table className="w-full text-xs border-collapse">
                      <thead>
                        <tr className="bg-gray-200">
                          <th className="border p-1">#</th>
                          <th className="border p-1 text-left">Name</th>
                          <th className="border p-1">Gr</th>
                          <th className="border p-1">MIN</th>
                          <th className="border p-1">W</th>
                          <th className="border p-1">L</th>
                          <th className="border p-1">T</th>
                          <th className="border p-1">SOG</th>
                          <th className="border p-1">SV</th>
                          <th className="border p-1">GA</th>
                          <th className="border p-1">GAA</th>
                          <th className="border p-1">SV%</th>
                          <th className="border p-1">SO</th>
                        </tr>
                      </thead>
                      <tbody>
                        {opponentData.roster
                          .filter(p => p.position === 'G')
                          .sort((a, b) => parseInt(a.number) - parseInt(b.number))
                          .map(player => (
                            <tr key={player.id}>
                              <td className="border p-1 font-bold text-center">{player.number}</td>
                              <td className="border p-1">{player.firstName} {player.lastName}</td>
                              <td className="border p-1 text-center">{player.grade}</td>
                              <td className="border p-1 text-center">{player.goalieStats?.min || '0:00'}</td>
                              <td className="border p-1 text-center">{player.goalieStats?.w || 0}</td>
                              <td className="border p-1 text-center">{player.goalieStats?.l || 0}</td>
                              <td className="border p-1 text-center">{player.goalieStats?.t || 0}</td>
                              <td className="border p-1 text-center">{player.goalieStats?.sog || 0}</td>
                              <td className="border p-1 text-center">{player.goalieStats?.sv || 0}</td>
                              <td className="border p-1 text-center">{player.goalieStats?.ga || 0}</td>
                              <td className="border p-1 text-center font-bold">{player.goalieStats?.gaa.toFixed(2) || '0.00'}</td>
                              <td className="border p-1 text-center font-bold">{player.goalieStats?.svp || '.000'}</td>
                              <td className="border p-1 text-center">{player.goalieStats?.so || 0}</td>
                            </tr>
                          ))}
                      </tbody>
                    </table>
                  </div>
                </div>

                <div className="mt-2">
                  <h2 style={{ fontSize: '14px', color: opponentColors.primary }} className="font-bold mb-1">Diagrams & Notes</h2>
                  
                  <div className="grid grid-cols-3 gap-1">
                    {['image1', 'image2', 'image3'].map((key, idx) => (
                      <div key={key} className="border-2 border-dashed border-gray-400 rounded p-1 bg-gray-50" style={{ minHeight: '100px', position: 'relative' }}>
                        {diagramImages[key] ? (
                          <div className="relative w-full h-full">
                            <img src={diagramImages[key]} alt={`Diagram ${idx + 1}`} className="w-full h-full object-contain" />
                            <button
                              onClick={() => setDiagramImages({...diagramImages, [key]: null})}
                              className="no-print absolute top-0 right-0 bg-red-500 text-white text-xs px-1 rounded"
                            >
                              ×
                            </button>
                          </div>
                        ) : (
                          <div>
                            <div style={{ fontSize: '8px' }} className="text-gray-500 italic mb-1">Image {idx + 1}</div>
                            <input
                              type="file"
                              accept="image/*"
                              onChange={(e) => {
                                const file = e.target.files[0];
                                if (file) {
                                  const reader = new FileReader();
                                  reader.onload = (event) => {
                                    setDiagramImages({...diagramImages, [key]: event.target.result});
                                  };
                                  reader.readAsDataURL(file);
                                }
                              }}
                              className="no-print w-full text-xs"
                            />
                            <div 
                              style={{ fontSize: '7px', minHeight: '40px' }} 
                              className="text-gray-400 border-dashed border border-gray-300 rounded mt-1 p-1"
                              contentEditable
                              onPaste={(e) => {
                                const items = e.clipboardData.items;
                                for (let i = 0; i < items.length; i++) {
                                  if (items[i].type.indexOf('image') !== -1) {
                                    e.preventDefault();
                                    const blob = items[i].getAsFile();
                                    const reader = new FileReader();
                                    reader.onload = (event) => {
                                      setDiagramImages({...diagramImages, [key]: event.target.result});
                                    };
                                    reader.readAsDataURL(blob);
                                    break;
                                  }
                                }
                              }}
                            >
                              Paste image or type notes...
                            </div>
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              </div>

              <style>{`
                @media print {
                  .no-print {
                    display: none !important;
                  }
                  
                  body {
                    margin: 0;
                    padding: 0;
                  }
                  
                  .print-page-1, .print-page-2 {
                    page-break-after: always;
                    margin: 0;
                    padding: 0.1in;
                  }
                  
                  .print-page-2 {
                    page-break-before: always;
                  }
                  
                  @page {
                    size: portrait;
                    margin: 0.1in;
                  }
                }
                
                .page-break {
                  page-break-before: always;
                }
              `}</style>
            </div>
          );
        };

        ReactDOM.render(<HockeyLinesChart />, document.getElementById('root'));
    </script>
</body>
</html>
