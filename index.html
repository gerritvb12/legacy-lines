<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MSHSL Legacy Lines</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            font-family: 'Arial Narrow', Arial, sans-serif;
        }
        
        /* Critical: Ensure colors print properly */
        @media print {
            /* Force yellow highlights to print */
            .bg-yellow-300, [style*="background-color: rgb(255, 255, 0)"], [style*="background-color: #FFFF00"] {
                background-color: #FFFF00 !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Force gray logo backgrounds to print */
            [style*="backgroundColor: '#EFEFEF'"], [style*="backgroundColor: '#efefef'"] {
                background-color: #EFEFEF !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Ensure all custom backgrounds print */
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;

        const Upload = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
            </svg>
        );
        
        const Settings = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m5.2-13.8l-1 1.7m-4.4 7.6l-1 1.7M23 12h-6m-6 0H5m13.8 5.2l-1.7-1m-7.6-4.4l-1.7-1"/>
            </svg>
        );
        
        const Printer = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/>
            </svg>
        );

        const X = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );

        const HockeyLinesChart = () => {
          const [myTeamSetup, setMyTeamSetup] = useState({
            teamName: 'Delano Tigers',
            logo: null,
            colors: { primary: '#fb923c', secondary: '#1f2937' },
            arena: 'Delano Area Sports Arena, Delano',
            careerStats: {}, // Will store career totals by player ID
            pronunciations: {}, // lastName: pronunciation mapping
            careerSeasonData: {
              season1: '', // 2024-25 (current/most recent)
              season2: '', // 2023-24
              season3: ''  // 2022-23
            }
          });

          const [myTeamData, setMyTeamData] = useState({
            teamName: '',
            nickname: '',
            record: { w: 0, l: 0, t: 0 },
            section: '2A',
            conference: 'WCC',
            stats: { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 },
            roster: [],
            nextGame: { gameNum: '', opponent: '', date: '', location: '', oppRecord: '', oppSection: '', oppConference: '' },
            headCoach: { name: '', careerRecord: { w: 0, l: 0, t: 0 }, seasonRecord: { w: 0, l: 0, t: 0 } },
            assistantCoaches: [],
            studentManager: '',
            injuries: []
          });

          const [opponentData, setOpponentData] = useState({
            teamName: '',
            nickname: '',
            record: { w: 0, l: 0, t: 0 },
            section: '',
            conference: '',
            stats: { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 },
            roster: [],
            headCoach: { name: '', careerRecord: { w: 0, l: 0, t: 0 }, seasonRecord: { w: 0, l: 0, t: 0 } },
            assistantCoaches: []
          });

          const [lines, setLines] = useState({
            line1: { lw: null, c: null, rw: null, color: 'GREEN' },
            line2: { lw: null, c: null, rw: null, color: 'RED' },
            line3: { lw: null, c: null, rw: null, color: 'BLUE' },
            line4: { lw: null, c: null, rw: null, color: 'YELLOW' },
            d1: { ld: null, rd: null },
            d2: { ld: null, rd: null },
            d3: { ld: null, rd: null },
            goalies: { starter: null, backup: null }
          });

          const [coachNotes, setCoachNotes] = useState({
            pk: '',
            pp: '',
            scoutNotes: { powerPlay: '', penaltyKill: '', keyPlayers: '' },
            showScoutNotes: true
          });
          
          const [diagramImages, setDiagramImages] = useState({
            image1: null,
            image2: null,
            image3: null,
            image4: null,
            image5: null
          });

          const [showSetup, setShowSetup] = useState(false);
          const [showCareerStats, setShowCareerStats] = useState(false);
          const [showPronunciations, setShowPronunciations] = useState(false);
          const [showImport, setShowImport] = useState(false);
          const [showColorPicker, setShowColorPicker] = useState(false);
          const [showHelp, setShowHelp] = useState(false);
          const [helpContent, setHelpContent] = useState({ title: '', steps: [] });
          const [importStep, setImportStep] = useState('myTeamHome');
          const [importText, setImportText] = useState('');
          const [spreadsheetData, setSpreadsheetData] = useState([]);
          const [spreadsheetHeaders, setSpreadsheetHeaders] = useState([]);
          
          // Help content for different sections
          const helpContents = {
            careerStats: {
              title: 'How to Import Career Stats',
              steps: [
                'Navigate to Legacy Hockey website',
                'Go to your team\'s "Player Stats" page for the {season} season',
                'Press Ctrl+A (Windows) or Command+A (Mac) to select all content',
                'Press Ctrl+C (Windows) or Command+C (Mac) to copy',
                'Return to Legacy Lines and paste here with Ctrl+V (Windows) or Command+V (Mac)'
              ]
            },
            myTeamHome: {
              title: 'How to Import Home Page Data',
              steps: [
                'Navigate to Legacy Hockey website',
                'Go to YOUR team\'s "Home" page',
                'Select all content (Ctrl+A or Command+A)',
                'Copy (Ctrl+C or Command+C)',
                'Return here and paste (Ctrl+V or Command+V)'
              ]
            },
            myTeamRoster: {
              title: 'How to Import Roster',
              steps: [
                'Go to your team\'s "Roster" page on Legacy Hockey',
                'Select all content (Ctrl+A or Command+A)',
                'Copy (Ctrl+C or Command+C)',
                'Return here and paste (Ctrl+V or Command+V)'
              ]
            },
            myTeamPlayerStats: {
              title: 'How to Import Player Stats',
              steps: [
                'Go to your team\'s "Player Stats" page on Legacy Hockey',
                'Select all content (Ctrl+A or Command+A)',
                'Copy (Ctrl+C or Command+C)',
                'Return here and paste (Ctrl+V or Command+V)'
              ]
            },
            oppHome: {
              title: 'How to Import Opponent Home Page Data',
              steps: [
                'Navigate to Legacy Hockey website',
                'Go to OPPONENT\'S team "Home" page',
                'Select all content (Ctrl+A or Command+A)',
                'Copy (Ctrl+C or Command+C)',
                'Return here and paste (Ctrl+V or Command+V)'
              ]
            },
            oppRoster: {
              title: 'How to Import Opponent Roster',
              steps: [
                'Go to opponent\'s team "Roster" page on Legacy Hockey',
                'Select all content (Ctrl+A or Command+A)',
                'Copy (Ctrl+C or Command+C)',
                'Return here and paste (Ctrl+V or Command+V)'
              ]
            },
            oppPlayerStats: {
              title: 'How to Import Opponent Player Stats',
              steps: [
                'Go to opponent\'s team "Player Stats" page on Legacy Hockey',
                'Select all content (Ctrl+A or Command+A)',
                'Copy (Ctrl+C or Command+C)',
                'Return here and paste (Ctrl+V or Command+V)'
              ]
            }
          };
          
          const openHelp = (type, season = '') => {
            let content = { ...helpContents[type] };
            if (season) {
              content.steps = content.steps.map(step => step.replace('{season}', season));
            }
            setHelpContent(content);
            setShowHelp(true);
          };
          
          // Calculate season years dynamically - updates on June 1st each year
          const getSeasonYears = () => {
            const now = new Date();
            const currentYear = now.getFullYear(); // 2025
            const currentMonth = now.getMonth(); // 0-11 (0 = January, 5 = June)
            
            // We want to show 2024-2025 until June 1, 2026
            // Current date: October 24, 2025
            // Logic: Always show the season that STARTED in the previous calendar year
            // until June 1st of the FOLLOWING year
            
            let seasonStartYear;
            if (currentMonth >= 5) { // June (5) or later
              // On/after June 1st, use PREVIOUS year as the season start
              seasonStartYear = currentYear - 1;
            } else {
              // Before June, use TWO years back as the season start
              seasonStartYear = currentYear - 2;
            }
            
            return {
              season1: `${seasonStartYear}-${seasonStartYear + 1}`,
              season2: `${seasonStartYear - 1}-${seasonStartYear}`,
              season3: `${seasonStartYear - 2}-${seasonStartYear - 1}`
            };
          };
          
          // Determine if current step should use spreadsheet view
          const isSpreadsheetStep = (step) => {
            return false; // Disabled - using simple text import for all
          };
          
          // Parse pasted spreadsheet data
          const handleSpreadsheetPaste = (text) => {
            console.log('=== Parsing spreadsheet paste ===');
            console.log('Raw text length:', text.length);
            console.log('First 200 chars:', text.substring(0, 200));
            
            const lines = text.split('\n').filter(l => l.trim());
            console.log('Total lines:', lines.length);
            console.log('First line:', lines[0]);
            
            const rows = lines.map(line => line.split('\t'));
            console.log('First row split by tabs:', rows[0]);
            console.log('First row length:', rows[0].length);
            
            if (rows.length > 0) {
              setSpreadsheetHeaders(rows[0]); // First row is headers
              setSpreadsheetData(rows.slice(1)); // Rest is data
              console.log('Set headers:', rows[0]);
              console.log('Set data rows:', rows.length - 1);
            }
          };
          
          // Process spreadsheet data into player stats
          const processSpreadsheetStats = (headers, data, existingRoster) => {
            // Find column indices
            const getColIndex = (possibleNames) => {
              return headers.findIndex(h => possibleNames.some(name => 
                h.toLowerCase().includes(name.toLowerCase())
              ));
            };
            
            const numCol = getColIndex(['#', 'number']);
            const nameCol = getColIndex(['name', 'player']);
            const gpCol = getColIndex(['gp']);
            const gCol = getColIndex(['g', 'goals']) !== -1 && !headers[getColIndex(['g', 'goals'])].toLowerCase().includes('ga') ? getColIndex(['g', 'goals']) : -1;
            const aCol = getColIndex(['a', 'assists']);
            const ptsCol = getColIndex(['pts', 'points']);
            const ppgCol = getColIndex(['ppg']);
            const ppaCol = getColIndex(['ppa']);
            const shCol = getColIndex(['sh']);
            const shaCol = getColIndex(['sha']);
            const pimCol = getColIndex(['pim', 'pen']);
            const plusMinusCol = getColIndex(['+/-', 'plus', 'minus']);
            const fowCol = getColIndex(['fow']);
            const folCol = getColIndex(['fol']);
            
            // Update roster with stats
            const updatedRoster = existingRoster.map(player => {
              // Find matching row by name or number
              const matchingRow = data.find(row => {
                const rowName = nameCol >= 0 ? row[nameCol] : '';
                const rowNum = numCol >= 0 ? row[numCol] : '';
                return rowName.includes(player.lastName) || rowNum === player.number;
              });
              
              if (matchingRow) {
                return {
                  ...player,
                  stats: {
                    gp: gpCol >= 0 ? parseInt(matchingRow[gpCol]) || 0 : 0,
                    g: gCol >= 0 ? parseInt(matchingRow[gCol]) || 0 : 0,
                    a: aCol >= 0 ? parseInt(matchingRow[aCol]) || 0 : 0,
                    pts: ptsCol >= 0 ? parseInt(matchingRow[ptsCol]) || 0 : 0,
                    ppg: ppgCol >= 0 ? parseInt(matchingRow[ppgCol]) || 0 : 0,
                    ppa: ppaCol >= 0 ? parseInt(matchingRow[ppaCol]) || 0 : 0,
                    sh: shCol >= 0 ? parseInt(matchingRow[shCol]) || 0 : 0,
                    sha: shaCol >= 0 ? parseInt(matchingRow[shaCol]) || 0 : 0,
                    pim: pimCol >= 0 ? parseInt(matchingRow[pimCol]) || 0 : 0,
                    plusMinus: plusMinusCol >= 0 ? parseInt(matchingRow[plusMinusCol]) || 0 : 0,
                    fow: fowCol >= 0 ? parseInt(matchingRow[fowCol]) || 0 : 0,
                    fol: folCol >= 0 ? parseInt(matchingRow[folCol]) || 0 : 0
                  }
                };
              }
              
              return player;
            });
            
            return updatedRoster;
          };
          
          const [selectedPlayer, setSelectedPlayer] = useState(null);
          const [opponentLogo, setOpponentLogo] = useState(null);
          const [opponentColors, setOpponentColors] = useState({ primary: '#dc2626', secondary: '#991b1b' });
          const [careerStatsImport, setCareerStatsImport] = useState({
            lastSeason: '',
            twoSeasonsAgo: '',
            threeSeasonsAgo: ''
          });

          const colorOptions = ['GREEN', 'RED', 'BLUE', 'YELLOW', 'WHITE', 'BLACK', 'DARK GRAY', 'LIGHT GRAY'];
          const colorClasses = {
            'GREEN': 'bg-green-100 border-green-600',
            'RED': 'bg-red-100 border-red-600',
            'BLUE': 'bg-blue-100 border-blue-600',
            'YELLOW': 'bg-yellow-100 border-yellow-600',
            'WHITE': 'bg-white border-gray-800',
            'BLACK': 'bg-gray-900 border-gray-900',
            'DARK GRAY': 'bg-gray-600 border-gray-800',
            'LIGHT GRAY': 'bg-gray-200 border-gray-500'
          };

          const importSteps = [
  { key: 'myTeamHome', label: 'My Team - Legacy Home', team: 'mine' },
  { key: 'myTeamRoster', label: 'My Team - Legacy Roster', team: 'mine' },
  { key: 'myTeamPlayerStats', label: 'My Team - Legacy Player Stats', team: 'mine' },
  { key: 'oppLogo', label: 'Opponent - Logo', team: 'opponent', isLogo: true },
  { key: 'oppHome', label: 'Opponent - Legacy Home', team: 'opponent' },
  { key: 'oppRoster', label: 'Opponent - Legacy Roster', team: 'opponent' },
  { key: 'oppPlayerStats', label: 'Opponent - Legacy Player Stats', team: 'opponent' }
];

          useEffect(() => {
            const saved = localStorage.getItem('myTeamSetup');
            if (saved) {
              setMyTeamSetup(JSON.parse(saved));
            }
          }, []);

          useEffect(() => {
            localStorage.setItem('myTeamSetup', JSON.stringify(myTeamSetup));
          }, [myTeamSetup]);

          // Career Stats localStorage helpers
          const saveCareerStatsToStorage = (roster) => {
            const careerData = {};
            roster.forEach(player => {
              const key = `${player.lastName?.toUpperCase()}_${player.firstName?.charAt(0)?.toUpperCase()}`;
              
              if (player.baseCareerStats && player.baseCareerStats.gp > 0) {
                careerData[key] = {
                  type: 'skater',
                  data: player.baseCareerStats
                };
              }
              
              if (player.baseCareerGoalieStats && player.baseCareerGoalieStats.gp > 0) {
                careerData[key] = {
                  type: 'goalie',
                  data: player.baseCareerGoalieStats
                };
              }
            });
            
            localStorage.setItem('hockey-scout-career-stats', JSON.stringify(careerData));
            console.log('💾 Saved career stats to localStorage:', Object.keys(careerData).length, 'players');
          };
          
          const loadCareerStatsFromStorage = (roster) => {
            console.log('🔍 loadCareerStatsFromStorage CALLED with roster size:', roster.length);
            const stored = localStorage.getItem('hockey-scout-career-stats');
            console.log('🔍 localStorage contains:', stored ? 'YES' : 'NO');
            
            if (!stored) {
              console.log('❌ No career stats in localStorage');
              return roster;
            }
            
            const careerData = JSON.parse(stored);
            console.log('📂 Loading career stats from localStorage:', Object.keys(careerData).length, 'players');
            console.log('📂 Career data keys:', Object.keys(careerData));
            
            return roster.map(player => {
              const key = `${player.lastName?.toUpperCase()}_${player.firstName?.charAt(0)?.toUpperCase()}`;
              console.log(`🔍 Looking for key: ${key} for player: ${player.name} (Position: ${player.position})`);
              const savedCareer = careerData[key];
              
              if (savedCareer) {
                console.log(`✅ Found saved career for ${player.name}:`, savedCareer);
                
                // If player is a goalie in the roster, load goalie stats
                if (player.position === 'G' && savedCareer.type === 'goalie') {
                  player.baseCareerGoalieStats = savedCareer.data;
                  console.log(`✅ Loaded GOALIE career for ${player.name}`);
                } else if (savedCareer.type === 'skater') {
                  player.baseCareerStats = savedCareer.data;
                  console.log(`✅ Loaded SKATER career for ${player.name}`);
                }
              } else {
                console.log(`❌ No saved career found for ${player.name} (key: ${key})`);
              }
              
              return player;
            });
          };

          const parseHomePage = (text) => {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            let teamName = '';
            let nickname = '';
            let record = { w: 0, l: 0, t: 0 };
            let section = '';
            let conference = '';
            let headCoach = { name: '', careerRecord: { w: 0, l: 0, t: 0 }, seasonRecord: { w: 0, l: 0, t: 0 } };
            
            // Find team name - look for line that appears between "Subscribe" and "History"
            const subscribeIdx = lines.findIndex(l => l === 'Subscribe');
            const historyIdx = lines.findIndex(l => l === 'History');
            if (subscribeIdx >= 0 && historyIdx > subscribeIdx && historyIdx - subscribeIdx <= 3) {
              teamName = lines[subscribeIdx + 1];
            }
            
            // Find nickname - look for "Nickname:" line
            const nicknameIdx = lines.findIndex(l => l.startsWith('Nickname:'));
            if (nicknameIdx >= 0) {
              nickname = lines[nicknameIdx].split(':')[1]?.trim() || '';
            }
            
            // Look for the team record line - format: "15 11 1" (W L T)
for (let i = 0; i < lines.length; i++) {
  // Look for "Team Record" header followed by the stats
  if (lines[i].includes('Team Record') || lines[i].includes('TeamWLT')) {
    // The next line with 3 numbers is the record
    for (let j = i; j < i + 5; j++) {
      const parts = lines[j]?.split(/\s+/);
      if (parts && parts.length >= 3 && /^\d+$/.test(parts[0]) && /^\d+$/.test(parts[1]) && /^\d+$/.test(parts[2])) {
        record = { w: parseInt(parts[0]), l: parseInt(parts[1]), t: parseInt(parts[2]) };
        break;
      }
    }
    break;
  }
}
            
            const coachIdx = lines.findIndex(l => l.includes('Head Coach'));
            if (coachIdx >= 0 && coachIdx + 1 < lines.length) {
              headCoach.name = lines[coachIdx + 1];
              
              // Look for the career record in the next several lines
              // Format: "11th season, 191-84-5"
              for (let i = coachIdx + 1; i < coachIdx + 6 && i < lines.length; i++) {
                const careerLine = lines[i];
                const careerMatch = careerLine.match(/(\d+)-(\d+)-(\d+)/);
                
                if (careerMatch && careerLine.includes('season')) {
                  // Has career record
                  headCoach.careerRecord = { 
                    w: parseInt(careerMatch[1]), 
                    l: parseInt(careerMatch[2]), 
                    t: parseInt(careerMatch[3]) 
                  };
                  break;
                } else if (careerLine.includes('1st Year') || careerLine.includes('1st year')) {
                  // First year coach - NO career yet, will show current season only
                  headCoach.careerRecord = { w: 0, l: 0, t: 0 };
                  break;
                }
              }
              
              // Store current season record
              headCoach.seasonRecord = { ...record };
            }
            
            const sectionIdx = lines.findIndex(l => l.includes('Section:'));
            if (sectionIdx >= 0) section = lines[sectionIdx].split(':')[1]?.trim() || '';
            
            const confIdx = lines.findIndex(l => l.includes('Conference:'));
            if (confIdx >= 0) conference = lines[confIdx].split(':')[1]?.trim() || '';
            
            // Parse Assistant Coaches
            // Format: "Assistant Coaches:Kevin Johnson, Brad Musta, Ben Nelson, Nick Vatnsdal, Chad Wagner"
            let assistantCoaches = [];
            const assistantIdx = lines.findIndex(l => l.includes('Assistant Coaches:'));
            if (assistantIdx >= 0) {
              const assistantLine = lines[assistantIdx];
              const coachesPart = assistantLine.split('Assistant Coaches:')[1]?.trim();
              if (coachesPart) {
                assistantCoaches = coachesPart.split(',').map(name => name.trim()).filter(name => name);
              }
            }
            
            let stats = { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 };
            for (let i = 0; i < lines.length; i++) {
              const parts = lines[i].split(/\s+/);
              if (parts.length >= 10 && parts[0].match(/\d+/)) {
                stats.gpg = parseFloat(parts[3]) || 0;
                stats.gapg = parseFloat(parts[4]) || 0;
                stats.ppPct = parseFloat(parts[6]) || 0;
                stats.pkPct = parseFloat(parts[9]) || 0;
                break;
              }
            }
            
            // Parse Last Game
            // Format: "Last Game" -> score -> "Final" -> Scoreboard with team names
            // Team    1  2  3  T
            // Orono   0  2  3  5
            // Hibbing/Chisholm 0  0  1  1
            let lastGame = null;
            const lastGameIdx = lines.findIndex(l => l === 'Last Game');
            if (lastGameIdx >= 0) {
              const scoreLine = lines[lastGameIdx + 1];
              const scoreMatch = scoreLine?.match(/(\d+)\s*-\s*(\d+)/);
              
              if (scoreMatch) {
                const leftScore = parseInt(scoreMatch[1]);
                const rightScore = parseInt(scoreMatch[2]);
                
                // Find opponent in scoreboard - look for "Team" header, then find the line that's NOT our team
                let opponent = '';
                const teamHeaderIdx = lines.findIndex((l, idx) => idx > lastGameIdx && l.includes('Team') && l.includes('1') && l.includes('2'));
                
                if (teamHeaderIdx > 0) {
                  // Next 2-3 lines after "Team" header are team names with scores
                  for (let i = teamHeaderIdx + 1; i < Math.min(lines.length, teamHeaderIdx + 4); i++) {
                    const line = lines[i];
                    // Line should have team name followed by numbers (scores)
                    // Match: "Hibbing/Chisholm 0  0  1  1" or similar
                    const teamMatch = line.match(/^([A-Za-z\/\s-]+?)\s+\d/);
                    if (teamMatch) {
                      const potentialTeam = teamMatch[1].trim();
                      // Skip if it's our team name
                      if (potentialTeam.toLowerCase() !== teamName.toLowerCase()) {
                        // Capitalize properly
                        opponent = potentialTeam.split(' ').map(word => 
                          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                        ).join(' ');
                        break;
                      }
                    }
                  }
                }
                
                // Fallback: look for "Final" then next substantive line
                if (!opponent) {
                  const finalIdx = lines.findIndex((l, idx) => idx > lastGameIdx && l === 'Final');
                  if (finalIdx > 0) {
                    for (let i = finalIdx + 1; i < Math.min(lines.length, finalIdx + 4); i++) {
                      const line = lines[i];
                      if (line && line.length > 2 && line !== teamName && !line.includes('202') && !line.includes('@')) {
                        opponent = line.split(' ').map(word => 
                          word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                        ).join(' ');
                        break;
                      }
                    }
                  }
                }
                
                // Find date/location
                let date = '';
                let location = '';
                for (let i = lastGameIdx + 3; i < Math.min(lines.length, lastGameIdx + 15); i++) {
                  if (lines[i].includes('@') && lines[i].includes('202')) {
                    const parts = lines[i].split('|');
                    date = parts[0]?.trim() || lines[i];
                    location = parts[1]?.trim() || '';
                    break;
                  }
                }
                
                // Determine which score is ours
                const ourScore = rightScore;
                const oppScore = leftScore;
                
                lastGame = {
                  opponent,
                  ourScore,
                  oppScore,
                  result: ourScore > oppScore ? 'W' : ourScore < oppScore ? 'L' : 'T',
                  date,
                  location
                };
              }
            }
            
            // Parse Next Game
            // Format: Our team name -> "AT" or "VS" -> Opponent -> Date with @
            let nextGame = null;
            const nextGameIdx = lines.findIndex(l => l === 'Next Game');
            if (nextGameIdx >= 0) {
              let opponent = '';
              let isHome = false;
              let date = '';
              let time = '';
              
              // Look for "AT" (we're away) or "VS" (we're home)
              for (let i = nextGameIdx + 1; i < Math.min(lines.length, nextGameIdx + 10); i++) {
                if (lines[i] === 'AT') {
                  isHome = false;
                  // Opponent should be 2-3 lines after AT
                  for (let j = i + 1; j < Math.min(lines.length, i + 5); j++) {
                    if (lines[j] && lines[j].length > 2 && lines[j] !== teamName && !lines[j].includes('@')) {
                      opponent = lines[j];
                      break;
                    }
                  }
                  break;
                } else if (lines[i] === 'VS') {
                  isHome = true;
                  // Opponent should be 2-3 lines after VS
                  for (let j = i + 1; j < Math.min(lines.length, i + 5); j++) {
                    if (lines[j] && lines[j].length > 2 && lines[j] !== teamName && !lines[j].includes('@')) {
                      opponent = lines[j];
                      break;
                    }
                  }
                  break;
                }
              }
              
              // Look for date line (contains @ and time like "6:00p")
              for (let i = nextGameIdx + 1; i < Math.min(lines.length, nextGameIdx + 15); i++) {
                if (lines[i].includes('@') && (lines[i].includes(':') || lines[i].includes('p') || lines[i].includes('a'))) {
                  const parts = lines[i].split('@');
                  date = parts[0]?.trim() || '';
                  time = parts[1]?.trim() || '';
                  break;
                }
              }
              
              nextGame = {
                opponent,
                isHome,
                date,
                time,
                gameNum: '' // Will be calculated from record
              };
            }
            
            // Calculate next game number from record (W + L + T + 1)
            if (nextGame) {
              nextGame.gameNum = (record.w + record.l + record.t + 1).toString();
            }
            
            return { teamName, nickname, record, section, conference, headCoach, assistantCoaches, stats, lastGame, nextGame };
          };

          const parseRoster = (text, existingRoster = []) => {
  console.log('=== parseRoster called ===');
  console.log('Text length:', text.length);
  console.log('Existing roster size:', existingRoster.length);
  
  // Clean college commitments - add space before removing to prevent number concatenation
  text = text.replace(/([A-Z][a-z]+\s+University(?:\s+\([^)]+\))?)/gi, '  ');
  text = text.replace(/[A-Z][a-z]+\s+University(?:\s+\([^)]+\))?/gi, '');
  
  const roster = [];
  
  // Find ALL Position+Grade anchors: F9, F10, F11, F12, D9, D10, D11, D12, G9, G10, G11, G12
  const anchorRegex = /([FDG])(9|10|11|12)/g;
  const anchors = [];
  
  let match;
  while ((match = anchorRegex.exec(text)) !== null) {
    anchors.push({
      index: match.index,
      position: match[1],
      grade: match[2]
    });
  }
  
  console.log(`Found ${anchors.length} position+grade anchors`);
  
  // For each anchor, look backwards to find NUMBER + NAME
  for (let i = 0; i < anchors.length; i++) {
    const anchor = anchors[i];
    const anchorIndex = anchor.index;
    
    // Look back up to 80 characters to find the player number and name
    const lookbackDistance = 80;
    const lookbackStart = Math.max(0, anchorIndex - lookbackDistance);
    const beforeAnchor = text.substring(lookbackStart, anchorIndex);
    
    // Match: (NUMBER)(NAME) at the END of the lookback string
    // Name is one or more capitalized words, minimum 3 chars
    const namePattern = /(\d{1,2})([A-Z][a-z]{2,}(?:\s+[A-Z][a-z]+(?:\s+(?:Jr\.?|Sr\.?|II|III|IV))?)*)$/;
    const nameMatch = beforeAnchor.match(namePattern);
    
    if (!nameMatch) {
      continue; // Can't find valid number+name before this anchor
    }
    
    const number = nameMatch[1];
    const name = nameMatch[2].trim();
    
    // Validate: jersey number should be 1-99
    const numInt = parseInt(number);
    if (numInt < 1 || numInt > 99) {
      continue;
    }
    
    // Validate: name should be reasonable (not just numbers from height)
    if (name.length < 3) {
      continue;
    }
    
    // Check if there's a quote/apostrophe right before the number (height measurement)
    const charBeforeNumber = text.charAt(lookbackStart + beforeAnchor.length - nameMatch[0].length - 1);
    if (charBeforeNumber === "'" || charBeforeNumber === '"') {
      continue; // Skip - this is from a height like "5' 3"
    }
    
    const position = anchor.position;
    const grade = anchor.grade;
    
    // Split name into first and last
    const nameParts = name.split(' ');
    const lastName = nameParts[nameParts.length - 1];
    const firstName = nameParts.slice(0, -1).join(' ');
    
    // Look forward from anchor to find optional handedness and DOB
    const nextAnchorIndex = i < anchors.length - 1 ? anchors[i + 1].index : text.length;
    const afterAnchor = text.substring(anchorIndex + 2, Math.min(anchorIndex + 100, nextAnchorIndex));
    
    let shoots = '';
    // Check for various handedness formats
    if (afterAnchor.match(/Catches\s+L/)) shoots = 'L';
    else if (afterAnchor.match(/Catches\s+R/)) shoots = 'R';
    else if (afterAnchor.match(/Left(?!\d)/)) shoots = 'L';
    else if (afterAnchor.match(/Right(?!\d)/)) shoots = 'R';
    else if (afterAnchor.match(/\bL(?!\d)/)) shoots = 'L';
    else if (afterAnchor.match(/\bR(?!\d)/)) shoots = 'R';
    
    let dobYear = '';
    const yearMatch = afterAnchor.match(/\b(19|20)\d{2}\b/);
    if (yearMatch) {
      dobYear = yearMatch[0];
    }
    
    // Check if this player already exists in the existing roster (match by name)
    const existingPlayer = existingRoster.find(p => 
      p.lastName?.toUpperCase() === lastName.toUpperCase() && 
      p.firstName?.charAt(0)?.toUpperCase() === firstName.charAt(0)?.toUpperCase()
    );
    
    roster.push({
      id: `${number}-${lastName}`,
      number: number,
      name: name,
      firstName: firstName,
      lastName: lastName,
      position: position,
      grade: grade,
      dobYear: dobYear,
      handed: shoots,
      shoots: shoots,
      stats: { gp: 0, g: 0, a: 0, pts: 0, ppg: 0, ppa: 0, sh: 0, sha: 0, pim: 0, plusMinus: 0, fow: 0, fol: 0 },
      goalieStats: position === 'G' ? { gp: 0, min: '0:00', w: 0, l: 0, t: 0, sog: 0, ga: 0, sv: 0, gaa: 0, svp: '.000', so: 0 } : null,
      // PRESERVE career data if it exists from previous roster
      baseCareerStats: existingPlayer?.baseCareerStats || undefined,
      baseCareerGoalieStats: existingPlayer?.baseCareerGoalieStats || undefined,
      pronunciation: existingPlayer?.pronunciation || undefined
    });
  }
  
  console.log('Final roster size:', roster.length);
  console.log('Roster:', roster);
  return roster;
};

          const parseSchedule = (text) => {
  const lines = text.split('\n').map(l => l.trim());
  let gameNum = 0;
  let nextGame = { gameNum: '', opponent: '', date: '', time: '', location: '', oppRecord: '', oppSection: '', oppConference: '' };
  let lastGame = { gameNum: '', opponent: '', date: '', time: '', location: '', oppRecord: '', oppSection: '', oppConference: '' };
  let foundNextGame = false;
  
  // Parse each game line by line
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Look for date line (starts with day of week) - only count lines that have game info following
    if (line.match(/^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)/) && i + 1 < lines.length) {
      // Check if this is actually a game (next line should be score or "-")
      const nextLine = lines[i + 1];
      
      // Skip if next line is empty or doesn't look like a score/dash
      if (!nextLine || (!nextLine.includes('-') && !nextLine.match(/^\d+$/))) {
        continue;
      }
      
      gameNum++;
      
      // Extract game details
      const opponentLine = lines[i + 2] || '';
      const locationLine = lines[i + 3] || '';
      
      // Store as last game
      lastGame.gameNum = gameNum.toString();
      lastGame.date = line;
      lastGame.opponent = opponentLine.replace('@', '').trim();
      lastGame.location = locationLine;
      
      // Check if this game hasn't been played yet (score is just "-")
      if (nextLine === '-' && !foundNextGame) {
        // This is the next unplayed game!
        nextGame = { ...lastGame };
        foundNextGame = true;
      }
    }
  }
  
  // If no unplayed game found, return the last game
  return foundNextGame ? nextGame : lastGame;
};

          const parsePlayerStats = (text, existingRoster) => {
            console.log('=== parsePlayerStats called ===');
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            console.log('Total lines:', lines.length);
            
            const updatedRoster = [...existingRoster];
            let inSkaterSection = false;
            let inGoalieSection = false;
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // Detect sections
              if (line === 'Skater') {
                inSkaterSection = true;
                inGoalieSection = false;
                console.log('Found Skater section at line', i);
                continue;
              }
              if (line === 'Goalie') {
                inSkaterSection = false;
                inGoalieSection = true;
                console.log('Found Goalie section at line', i);
                continue;
              }
              
              // Skip headers
              if (line === '#' || line === 'Name' || line === 'GP' || line.includes('AVG PTS')) continue;
              
              // Split by tabs
              const fields = line.split('\t').filter(f => f.trim());
              
              // Need at least player number and name
              if (fields.length < 3) continue;
              
              const number = fields[0];
              const name = fields[1];
              
              // Must start with a digit
              if (!/^\d+$/.test(number)) continue;
              
              if (inSkaterSection) {
                const player = updatedRoster.find(p => p.number === number && p.position !== 'G');
                
                if (player && fields.length >= 6) {
                  // DEBUG: Check if baseCareer exists
                  if (player.baseCareerStats) {
                    console.log(`🔍 ${name} HAS baseCareer:`, player.baseCareerStats);
                  } else {
                    console.log(`⚠️ ${name} has NO baseCareer (rookie or not imported yet)`);
                  }
                  
                  // Current season stats
                  const currentStats = {
                    gp: parseInt(fields[2]) || 0,
                    g: parseInt(fields[3]) || 0,
                    a: parseInt(fields[4]) || 0,
                    pts: parseInt(fields[5]) || 0,
                    ppg: parseInt(fields[8]) || 0,
                    ppa: parseInt(fields[9]) || 0,
                    sh: parseInt(fields[10]) || 0,
                    sha: parseInt(fields[11]) || 0,
                    pim: parseInt(fields[13]) || 0,
                    fow: parseInt(fields[14]) || 0,
                    fol: parseInt(fields[15]) || 0,
                    plusMinus: parseInt(fields[19]) || 0
                  };
                  
                  player.stats = currentStats;
                  
                  // Career stats = base career (from My Team Setup) + current season
                  // If no baseCareer exists, player is a rookie - career = current only
                  const baseCareer = player.baseCareerStats || { gp: 0, g: 0, a: 0, pts: 0, plusMinus: 0, fow: 0, fol: 0 };
                  const totalFOW = (baseCareer.fow || 0) + currentStats.fow;
                  const totalFOL = (baseCareer.fol || 0) + currentStats.fol;
                  const careerFaceoffPct = (totalFOW + totalFOL > 0) ? ((totalFOW / (totalFOW + totalFOL)) * 100).toFixed(1) : '0.0';
                  
                  player.careerStats = {
                    gp: baseCareer.gp + currentStats.gp,
                    g: baseCareer.g + currentStats.g,
                    a: baseCareer.a + currentStats.a,
                    pts: baseCareer.pts + currentStats.pts,
                    plusMinus: baseCareer.plusMinus + currentStats.plusMinus,
                    faceoffPct: careerFaceoffPct,
                    fow: totalFOW,
                    fol: totalFOL
                  };
                  
                  console.log(`✅ Updated ${name}:`, player.stats, 'Career:', player.careerStats);
                }
              } else if (inGoalieSection) {
                const player = updatedRoster.find(p => p.number === number && p.position === 'G');
                
                if (player && player.goalieStats && fields.length >= 10) {
                  // Current season goalie stats
                  // Columns: # | Name | GP | MIN | W | L | T | SOG | GA | SV | GAA | SV% | SO
                  const currentGoalieStats = {
                    gp: parseInt(fields[2]) || 0,      // GP
                    min: fields[3] || '0:00',          // MIN
                    w: parseInt(fields[4]) || 0,       // W
                    l: parseInt(fields[5]) || 0,       // L
                    t: parseInt(fields[6]) || 0,       // T
                    sog: parseInt(fields[7]) || 0,     // SOG
                    ga: parseInt(fields[8]) || 0,      // GA
                    sv: parseInt(fields[9]) || 0,      // SV
                    gaa: parseFloat(fields[10]) || 0,  // GAA
                    svp: fields[11] || '.000',         // SV%
                    so: parseInt(fields[12]) || 0      // SO
                  };
                  
                  player.goalieStats = currentGoalieStats;
                  
                  // Career = base career (from My Team Setup) + current season
                  console.log(`🔍 ${name} baseCareerGoalieStats:`, player.baseCareerGoalieStats);
                  const baseCareer = player.baseCareerGoalieStats || { gp: 0, min: '0:00', w: 0, l: 0, t: 0, so: 0, ga: 0, sv: 0 };
                  console.log(`🔍 ${name} using baseCareer:`, baseCareer);
                  
                  // Convert minutes to total seconds
                  const parseMinutes = (minStr) => {
                    const parts = minStr.split(':');
                    return parseInt(parts[0]) * 60 + parseInt(parts[1] || 0);
                  };
                  
                  const baseSeconds = parseMinutes(baseCareer.min);
                  const currSeconds = parseMinutes(currentGoalieStats.min);
                  const totalSeconds = baseSeconds + currSeconds;
                  const totalMinStr = `${Math.floor(totalSeconds / 60)}:${String(totalSeconds % 60).padStart(2, '0')}`;
                  
                  const totalGA = baseCareer.ga + currentGoalieStats.ga;
                  const totalSV = baseCareer.sv + currentGoalieStats.sv;
                  const totalSOG = totalGA + totalSV;
                  
                  // Career GAA formula: Total GA / (Total Minutes / 51)
                  const totalMinutes = totalSeconds / 60;
                  const careerGAA = totalMinutes > 0 ? (totalGA / (totalMinutes / 51)).toFixed(2) : '0.00';
                  
                  // Career SV%
                  const careerSVP = totalSOG > 0 ? (totalSV / totalSOG).toFixed(3) : '.000';
                  
                  player.careerGoalieStats = {
                    gp: baseCareer.gp + currentGoalieStats.gp,
                    min: totalMinStr,
                    w: baseCareer.w + currentGoalieStats.w,
                    l: baseCareer.l + currentGoalieStats.l,
                    t: baseCareer.t + currentGoalieStats.t,
                    so: baseCareer.so + currentGoalieStats.so,
                    ga: totalGA,
                    sv: totalSV,
                    gaa: parseFloat(careerGAA),
                    svp: careerSVP
                  };
                  
                  console.log(`✅ Updated goalie ${name}:`, player.goalieStats, 'Career:', player.careerGoalieStats);
                }
              }
            }
            
            console.log('Final updated roster:', updatedRoster);
            return updatedRoster;
          };

          const parseCareerStats = (text, existingRoster) => {
            console.log('=== parseCareerStats called ===');
            const lines = text.split('\n').map(l => l.trim()).filter(l => l);
            console.log('Total lines:', lines.length);
            
            const updatedRoster = [...existingRoster];
            let inSkaterSection = false;
            let inGoalieSection = false;
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // Detect sections
              if (line === 'Skater') {
                inSkaterSection = true;
                inGoalieSection = false;
                console.log('Found Skater section at line', i);
                continue;
              }
              if (line === 'Goalie') {
                inSkaterSection = false;
                inGoalieSection = true;
                console.log('Found Goalie section at line', i);
                continue;
              }
              
              // Skip headers
              if (line === '#' || line === 'Name' || line === 'GP' || line.includes('AVG PTS')) continue;
              
              // Split by tabs
              const fields = line.split('\t').filter(f => f.trim());
              
              // Need at least player number and name
              if (fields.length < 3) continue;
              
              const number = fields[0];
              const name = fields[1];
              
              // Must start with a digit
              if (!/^\d+$/.test(number)) continue;
              
              if (inSkaterSection) {
                // Normalize number for matching (trim and compare as strings)
                const normalizedNumber = number.trim();
                
                // Extract last name and first initial from career import
                const careerNameParts = name.trim().split(/\s+/);
                const careerFirstInitial = careerNameParts[0]?.charAt(0)?.toUpperCase() || '';
                const careerLastName = careerNameParts[careerNameParts.length - 1]?.toUpperCase() || '';
                
                // Try to match by: 1) Last Name + First Initial (primary), 2) Jersey Number (fallback)
                let player = updatedRoster.find(p => {
                  if (p.position === 'G') return false; // Skip goalies
                  
                  const rosterFirstInitial = p.firstName?.charAt(0)?.toUpperCase() || '';
                  const rosterLastName = p.lastName?.toUpperCase() || '';
                  
                  // Primary match: Last Name + First Initial
                  const nameMatch = rosterLastName === careerLastName && rosterFirstInitial === careerFirstInitial;
                  
                  // Fallback match: Jersey Number (if name doesn't match)
                  const numberMatch = p.number.toString().trim() === normalizedNumber;
                  
                  return nameMatch || numberMatch;
                });
                
                // Log matching attempt
                if (player) {
                  const matchType = (player.lastName?.toUpperCase() === careerLastName && 
                                    player.firstName?.charAt(0)?.toUpperCase() === careerFirstInitial) 
                                    ? 'by NAME' : 'by NUMBER';
                  console.log(`Trying to match skater #${normalizedNumber} (${name}): ✅ FOUND ${matchType} → #${player.number} ${player.name}`);
                } else {
                  console.log(`Trying to match skater #${normalizedNumber} (${name}): ❌ NOT FOUND`);
                }
                
                if (player && fields.length >= 6) {
                  // This season's stats from career import
                  const seasonGP = parseInt(fields[2]) || 0;
                  const seasonG = parseInt(fields[3]) || 0;
                  const seasonA = parseInt(fields[4]) || 0;
                  const seasonPts = parseInt(fields[5]) || 0;
                  const seasonPlusMinus = parseInt(fields[19]) || 0;
                  const seasonFOW = parseInt(fields[14]) || 0;
                  const seasonFOL = parseInt(fields[15]) || 0;
                  
                  // Add to existing base career (for multiple season imports)
                  const existing = player.baseCareerStats || { gp: 0, g: 0, a: 0, pts: 0, plusMinus: 0, fow: 0, fol: 0 };
                  
                  player.baseCareerStats = {
                    gp: existing.gp + seasonGP,
                    g: existing.g + seasonG,
                    a: existing.a + seasonA,
                    pts: existing.pts + seasonPts,
                    plusMinus: existing.plusMinus + seasonPlusMinus,
                    fow: existing.fow + seasonFOW,
                    fol: existing.fol + seasonFOL
                  };
                  
                  console.log(`✅ Base career for ${name}:`, player.baseCareerStats);
                } else if (!player) {
                  console.log(`❌ No roster match for #${normalizedNumber} ${name}`);
                }
              } else if (inGoalieSection) {
                // Normalize number for matching
                const normalizedNumber = number.trim();
                
                // Extract last name and first initial from career import
                const careerNameParts = name.trim().split(/\s+/);
                const careerFirstInitial = careerNameParts[0]?.charAt(0)?.toUpperCase() || '';
                const careerLastName = careerNameParts[careerNameParts.length - 1]?.toUpperCase() || '';
                
                // Try to match by: 1) Last Name + First Initial (primary), 2) Jersey Number (fallback)
                let player = updatedRoster.find(p => {
                  if (p.position !== 'G') return false; // Only goalies
                  
                  const rosterFirstInitial = p.firstName?.charAt(0)?.toUpperCase() || '';
                  const rosterLastName = p.lastName?.toUpperCase() || '';
                  
                  // Primary match: Last Name + First Initial
                  const nameMatch = rosterLastName === careerLastName && rosterFirstInitial === careerFirstInitial;
                  
                  // Fallback match: Jersey Number
                  const numberMatch = p.number.toString().trim() === normalizedNumber;
                  
                  return nameMatch || numberMatch;
                });
                
                // Log matching attempt
                if (player) {
                  const matchType = (player.lastName?.toUpperCase() === careerLastName && 
                                    player.firstName?.charAt(0)?.toUpperCase() === careerFirstInitial) 
                                    ? 'by NAME' : 'by NUMBER';
                  console.log(`Trying to match goalie #${normalizedNumber} (${name}): ✅ FOUND ${matchType} → #${player.number} ${player.name}`);
                } else {
                  console.log(`Trying to match goalie #${normalizedNumber} (${name}): ❌ NOT FOUND`);
                }
                
                if (player && fields.length >= 10) {
                  // Career import goalie stats
                  // Columns: # | Name | GP | MIN | W | L | T | SOG | GA | SV | GAA | SV% | SO
                  const seasonGP = parseInt(fields[2]) || 0;      // GP
                  const seasonMin = fields[3] || '0:00';          // MIN
                  const seasonW = parseInt(fields[4]) || 0;       // W
                  const seasonL = parseInt(fields[5]) || 0;       // L
                  const seasonT = parseInt(fields[6]) || 0;       // T
                  // Skip SOG (fields[7]) - we calculate from GA + SV
                  const seasonGA = parseInt(fields[8]) || 0;      // GA
                  const seasonSV = parseInt(fields[9]) || 0;      // SV
                  // Skip GAA (fields[10]) - we calculate it
                  // Skip SV% (fields[11]) - we calculate it
                  const seasonSO = parseInt(fields[12]) || 0;     // SO
                  
                  // Convert minutes to seconds for accumulation
                  const parseMinutes = (minStr) => {
                    const parts = minStr.split(':');
                    return parseInt(parts[0]) * 60 + parseInt(parts[1] || 0);
                  };
                  
                  const existing = player.baseCareerGoalieStats || { gp: 0, min: '0:00', w: 0, l: 0, t: 0, so: 0, ga: 0, sv: 0 };
                  const existingSeconds = parseMinutes(existing.min);
                  const seasonSeconds = parseMinutes(seasonMin);
                  const totalSeconds = existingSeconds + seasonSeconds;
                  const totalMinStr = `${Math.floor(totalSeconds / 60)}:${String(totalSeconds % 60).padStart(2, '0')}`;
                  
                  player.baseCareerGoalieStats = {
                    gp: existing.gp + seasonGP,
                    min: totalMinStr,
                    w: existing.w + seasonW,
                    l: existing.l + seasonL,
                    t: existing.t + seasonT,
                    so: existing.so + seasonSO,
                    ga: existing.ga + seasonGA,
                    sv: existing.sv + seasonSV
                  };
                  
                  console.log(`✅ Base career goalie for ${name}:`, player.baseCareerGoalieStats);
                } else if (!player) {
                  console.log(`❌ No roster match for goalie #${normalizedNumber} ${name}`);
                }
              }
            }
            
            console.log('Final roster with career stats:', updatedRoster);
            return updatedRoster;
          };

          const parseTeamStats = (text) => {
            console.log('parseTeamStats called with text:', text.substring(0, 200));
            const lines = text.split('\n').map(l => l.trim());
            let stats = { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 };
            
            // Look for the line with team stats - format: Delano 27 4.00 3.15 89 25.8 85 23 72.9
            // We need: GPG (index 2), GAPG (index 3), PP% (index 5), PK% (index 8)
            for (let i = 0; i < lines.length; i++) {
              const parts = lines[i].split(/\s+/);
              
              // Look for line starting with team name and has 9+ fields with the right pattern
              if (parts.length >= 9 && 
                  (parts[0] === 'Delano' || parts[0].includes('Tigers') || /^\d+$/.test(parts[1])) &&
                  parts[2]?.match(/^\d+\.\d+$/) && 
                  parts[3]?.match(/^\d+\.\d+$/)) {
                stats.gpg = parseFloat(parts[2]) || 0;
                stats.gapg = parseFloat(parts[3]) || 0;
                stats.ppPct = parseFloat(parts[5]) || 0;
                stats.pkPct = parseFloat(parts[8]) || 0;
                console.log('Found stats at line:', lines[i]);
                console.log('Parsed stats:', stats);
                break;
              }
            }
            
            console.log('parseTeamStats returning:', stats);
            return stats;
          };

          const handleLogoPaste = async (isSetup, isMyTeam) => {
            try {
              const clipboardItems = await navigator.clipboard.read();
              for (const item of clipboardItems) {
                for (const type of item.types) {
                  if (type.startsWith('image/')) {
                    const blob = await item.getType(type);
                    const reader = new FileReader();
                    reader.onload = (event) => {
                      const logoUrl = event.target.result;
                      
                      if (isSetup) {
                        setMyTeamSetup(prev => ({ ...prev, logo: logoUrl }));
                      } else if (isMyTeam) {
                        setMyTeamSetup(prev => ({ ...prev, logo: logoUrl }));
                      } else {
                        setOpponentLogo(logoUrl);
                      }
                    };
                    reader.readAsDataURL(blob);
                    return;
                  }
                }
              }
              alert('No image found in clipboard.');
            } catch (err) {
              alert('Unable to paste. Please use Choose File or copy an image first.');
            }
          };

          const handleLogoUpload = (e, isSetup, isMyTeam) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
              const logoUrl = event.target.result;
              
              if (isSetup) {
                setMyTeamSetup(prev => ({ ...prev, logo: logoUrl }));
              } else if (isMyTeam) {
                setMyTeamSetup(prev => ({ ...prev, logo: logoUrl }));
              } else {
                setOpponentLogo(logoUrl);
              }
            };
            reader.readAsDataURL(file);
          };

          const handleImport = () => {
            const text = importText;
            console.log('=== handleImport called ===');
            console.log('Current importStep:', importStep);
            console.log('Text length:', text.length);
            
            if (importStep === 'oppLogo') {
              const currentIdx = importSteps.findIndex(s => s.key === importStep);
              if (currentIdx < importSteps.length - 1) {
                setImportStep(importSteps[currentIdx + 1].key);
              }
              return;
            }
            
            try {
              if (importStep === 'myTeamHome') {
                console.log('Parsing Home Page:', text.substring(0, 200));
                const parsed = parseHomePage(text);
                console.log('Parsed result:', parsed);
                setMyTeamData(prev => ({ ...prev, ...parsed }));
              } else if (importStep === 'myTeamRoster') {
                console.log('📥 Importing MY TEAM roster...');
                let roster = parseRoster(text, myTeamData.roster);
                console.log('✅ Roster parsed, now loading career stats from localStorage...');
                // Auto-load career stats from localStorage
                roster = loadCareerStatsFromStorage(roster);
                console.log('✅ Career stats loaded, updating state...');
                setMyTeamData(prev => ({ ...prev, roster }));
              } else if (importStep === 'myTeamPlayerStats') {
                console.log('Processing player stats...');
                const updatedRoster = parsePlayerStats(text, myTeamData.roster);
                console.log('Updated roster:', updatedRoster);
                setMyTeamData(prev => ({ ...prev, roster: updatedRoster }));
              } else if (importStep === 'oppHome') {
                const parsed = parseHomePage(text);
                setOpponentData(prev => ({ ...prev, ...parsed }));
              } else if (importStep === 'oppRoster') {
                const roster = parseRoster(text, opponentData.roster);
                setOpponentData(prev => ({ ...prev, roster }));
              } else if (importStep === 'oppPlayerStats') {
                const updatedRoster = parsePlayerStats(text, opponentData.roster);
                setOpponentData(prev => ({ ...prev, roster: updatedRoster }));
              }
              
              setImportText('');
              
              const currentIdx = importSteps.findIndex(s => s.key === importStep);
              if (currentIdx < importSteps.length - 1) {
                setImportStep(importSteps[currentIdx + 1].key);
              } else {
                setShowImport(false);
              }
            } catch (error) {
              console.error('❌ Error in handleImport:', error);
              alert(`Error importing data: ${error.message}\nCheck console for details.`);
            }
          };

          const handleSkipStep = () => {
            // Save current data if any text was entered
            if (importText.trim()) {
              handleImport();
            } else {
              // Just move to next step if no data
              setImportText('');
              const currentIdx = importSteps.findIndex(s => s.key === importStep);
              if (currentIdx < importSteps.length - 1) {
                setImportStep(importSteps[currentIdx + 1].key);
              } else {
                setShowImport(false);
              }
            }
          };

            const handleBackStep = () => {
  // Save current data if any text was entered
  if (importText.trim()) {
    try {
      // Process the current step's data first
      if (importStep === 'myTeamHome') {
        const parsed = parseHomePage(importText);
        setMyTeamData(prev => ({ ...prev, ...parsed }));
      } else if (importStep === 'myTeamRoster') {
        let roster = parseRoster(importText, myTeamData.roster);
        roster = loadCareerStatsFromStorage(roster);
        setMyTeamData(prev => ({ ...prev, roster }));
      } else if (importStep === 'myTeamPlayerStats') {
        const updatedRoster = parsePlayerStats(importText, myTeamData.roster);
        setMyTeamData(prev => ({ ...prev, roster: updatedRoster }));
      } else if (importStep === 'oppHome') {
        const parsed = parseHomePage(importText);
        setOpponentData(prev => ({ ...prev, ...parsed }));
      } else if (importStep === 'oppRoster') {
        const roster = parseRoster(importText, opponentData.roster);
        setOpponentData(prev => ({ ...prev, roster }));
      } else if (importStep === 'oppPlayerStats') {
        const updatedRoster = parsePlayerStats(importText, opponentData.roster);
        setOpponentData(prev => ({ ...prev, roster: updatedRoster }));
      }
    } catch (error) {
      console.error('Error saving data on back:', error);
    }
  }
  
  // Then move to previous step
  setImportText('');
  const currentIdx = importSteps.findIndex(s => s.key === importStep);
  if (currentIdx > 0) {
    setImportStep(importSteps[currentIdx - 1].key);
  } else {
    // If at first step, go to last step (wrap around)
    setImportStep(importSteps[importSteps.length - 1].key);
  }
};

const handleSaveAndClose = () => {
  // Save current data if any text was entered
  if (importText.trim()) {
    try {
      // Process the current step's data
      if (importStep === 'myTeamHome') {
        const parsed = parseHomePage(importText);
        setMyTeamData(prev => ({ ...prev, ...parsed }));
      } else if (importStep === 'myTeamRoster') {
        let roster = parseRoster(importText, myTeamData.roster);
        roster = loadCareerStatsFromStorage(roster);
        setMyTeamData(prev => ({ ...prev, roster }));
      } else if (importStep === 'myTeamPlayerStats') {
        const updatedRoster = parsePlayerStats(importText, myTeamData.roster);
        setMyTeamData(prev => ({ ...prev, roster: updatedRoster }));
      } else if (importStep === 'oppHome') {
        const parsed = parseHomePage(importText);
        setOpponentData(prev => ({ ...prev, ...parsed }));
      } else if (importStep === 'oppRoster') {
        const roster = parseRoster(importText, opponentData.roster);
        setOpponentData(prev => ({ ...prev, roster }));
      } else if (importStep === 'oppPlayerStats') {
        const updatedRoster = parsePlayerStats(importText, opponentData.roster);
        setOpponentData(prev => ({ ...prev, roster: updatedRoster }));
      }
    } catch (error) {
      console.error('Error saving data on close:', error);
    }
  }
  
  // Clear and close
  setImportText('');
  setShowImport(false);
};

          const handlePlayerClick = (player, source) => {
            console.log('🔵 PLAYER CLICKED:', player.name, source);
            setSelectedPlayer({ player, source });
          };

          const handleSlotClick = (line, position) => {
            console.log('🟢 SLOT CLICKED:', line, position);
            if (!selectedPlayer) return;
            
            const newLines = { ...lines };
            const { player, source } = selectedPlayer;
            
            // Remove from old position if it was in lines
            if (source && source.line) {
              newLines[source.line][source.position] = null;
            }
            
            // Swap if slot occupied
            const existingPlayer = newLines[line][position];
            newLines[line][position] = player;
            
            if (existingPlayer && source && source.line) {
              newLines[source.line][source.position] = existingPlayer;
            }
            
            setLines(newLines);
            setSelectedPlayer(null);
          };

          const handleLineColorChange = (line, color) => {
            setLines({ ...lines, [line]: { ...lines[line], color } });
          };

          // Helper function to convert numeric grade to text
          const convertGradeToText = (grade) => {
            if (grade === 12 || grade === '12th' || grade === '12') return 'Senior';
            if (grade === 11 || grade === '11th' || grade === '11') return 'Junior';
            if (grade === 10 || grade === '10th' || grade === '10') return 'Sophomore';
            if (grade === 9 || grade === '9th' || grade === '9') return 'Freshman';
            return grade;
          };

          const PlayerCard = ({ player, source, compact = false, isPreview = false }) => {
            if (!player) return null;
            
            const cardRef = React.useRef(null);
            const numberRef = React.useRef(null);
            const nameRef = React.useRef(null);
            const pronunciationRef = React.useRef(null);
            
            // Look up pronunciation from myTeamSetup.pronunciations using player's last name
            const pronunciation = myTeamSetup.pronunciations[player.lastName] || '';
            
            // Ensure stats object exists with defaults
            const stats = player.stats || { gp: 0, g: 0, a: 0, pts: 0, pim: 0, plusMinus: 0, fow: 0, fol: 0 };
            const careerStats = player.careerStats || { gp: 0, g: 0, a: 0, pts: 0, plusMinus: 0, faceoffPct: '0.0', pim: 0 };
            const goalieStats = player.goalieStats || { gp: 0, min: '0:00', w: 0, l: 0, t: 0, ga: 0, sv: 0, gaa: 0, svp: '.000', so: 0, pim: 0 };
            const careerGoalieStats = player.careerGoalieStats || { gp: 0, min: '0:00', w: 0, l: 0, t: 0, ga: 0, sv: 0, gaa: 0, svp: '.000', so: 0, pim: 0 };
            
            const isGoalie = player.position === 'G';
            
            // Calculate faceoff percentage for current season
            const faceoffPct = stats.fow + stats.fol > 0 
              ? ((stats.fow / (stats.fow + stats.fol)) * 100).toFixed(1)
              : '0.0';
            
            // Helper: Convert grade to text
            const getGradeLabel = (grade) => {
              const gradeMap = { '9': 'Freshman', '10': 'Sophomore', '11': 'Junior', '12': 'Senior' };
              return gradeMap[grade] || grade;
            };
            
            // Helper: Format plus/minus with sign
            const formatPlusMinus = (value) => {
              if (!value || value === 0) return '+0';
              return value > 0 ? `+${value}` : `${value}`;
            };
            
            const gradeText = getGradeLabel(player.grade);
            
            // Build grade display with DOB year: "Senior - 2007"
            const gradeDisplay = player.dobYear ? `${gradeText} - ${player.dobYear}` : gradeText;
            
            // Position text - for goalies, show "Left Catch" or "Right Catch"
            const positionText = isGoalie 
              ? `${player.shoots === 'L' ? 'Left' : 'Right'} Catch`
              : player.handed === 'L' ? 'Left' : player.handed === 'R' ? 'Right' : '';
            
            const isSelected = selectedPlayer?.player.id === player.id;
            
            // Font sizes - stat-based hierarchy
            // For preview cards, use 0.3125 of normal size (was 0.25, increased by 25%)
            const fontScale = isPreview ? 0.3125 : 1;
            const statFontSize = `${8 * fontScale}pt`; // Same for all positions
            const nameFontSize = `${30 * fontScale}pt`; // 30pt for both goalies and skaters
            const infoFontSize = statFontSize; // handed, grade same as stats
            const pronunciationFontSize = `${10 * fontScale}pt`;
            
            // Auto-resize text effect
            React.useEffect(() => {
              const resizeText = (element, maxSize, minSize = 8) => {
                if (!element) return;
                let fontSize = maxSize;
                element.style.fontSize = `${fontSize}pt`;
                
                let iterations = 0;
                while ((element.scrollWidth > element.offsetWidth || element.scrollHeight > element.offsetHeight) 
                       && fontSize > minSize && iterations < 100) {
                  fontSize -= 0.5;
                  element.style.fontSize = `${fontSize}pt`;
                  iterations++;
                }
              };
              
              // Resize jersey number - scale ranges for preview cards
              if (numberRef.current) {
                const maxNumberSize = isPreview ? 32.8125 : 105; // 105 * 0.3125 = 32.8125
                const minNumberSize = isPreview ? 12.5 : 40;    // 40 * 0.3125 = 12.5
                resizeText(numberRef.current, maxNumberSize, minNumberSize);
              }
              
              // Resize player name - be more conservative to ensure it shows
              if (nameRef.current) {
                const baseMaxSize = 30; // Now 30pt for both goalies and skaters
                const maxNameSize = isPreview ? baseMaxSize * 0.3125 : baseMaxSize;
                const minNameSize = isPreview ? 3.125 : 10; // 10 * 0.3125 = 3.125
                resizeText(nameRef.current, maxNameSize, minNameSize);
              }
              
              // Resize pronunciation to fit on one line
              if (pronunciationRef.current && pronunciation) {
                const maxPronunciationSize = isPreview ? 10 * 0.3125 : 10; // 10pt base
                const minPronunciationSize = isPreview ? 2 : 6; // Min 6pt to stay readable
                resizeText(pronunciationRef.current, maxPronunciationSize, minPronunciationSize);
              }
            }, [player.number, player.name, pronunciation, isGoalie, isPreview]);
            
            return (
              <div
                ref={cardRef}
                onClick={() => handlePlayerClick(player, source)}
                className={`bg-white border-2 rounded cursor-pointer transition-all ${
                  isSelected ? 'border-blue-500 bg-blue-50' : 'border-gray-800'
                }`}
                style={{ 
                  height: '100%',
                  width: '100%',
                  padding: '1px',
                  userSelect: 'none',
                  display: 'flex',
                  fontFamily: "'Arial Narrow', Arial, sans-serif"
                }}
              >
                {/* LEFT SIDE: Jersey Number + Pronunciation */}
                <div style={{ 
                  width: '35%',
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'flex-start',
                  borderRight: '2px solid #333',
                  paddingRight: '2px'
                }}>
                  {/* Jersey Number - Auto-sizing from 110pt down to 40pt */}
                  <div 
                    ref={numberRef}
                    style={{ 
                      fontWeight: 'bold',
                      lineHeight: '0.9',
                      textAlign: 'center',
                      width: '100%',
                      overflow: 'hidden',
                      marginBottom: '4px'
                    }}
                  >
                    {player.number}
                  </div>
                  
                  {/* Pronunciation - 10pt italic */}
                  {pronunciation && (
                    <div 
                      ref={pronunciationRef}
                      style={{ 
                        fontSize: pronunciationFontSize,
                        fontStyle: 'italic',
                        lineHeight: '1',
                        textAlign: 'center',
                        marginTop: '1px',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden',
                        width: '100%'
                      }}>
                      "{pronunciation}"
                    </div>
                  )}
                </div>
                
                {/* RIGHT SIDE: Player Info & Stats */}
                <div style={{ 
                  width: '65%',
                  paddingLeft: '4px',
                  paddingRight: '4px',
                  display: 'flex',
                  flexDirection: 'column',
                  justifyContent: 'flex-start',
                  gap: '1px'
                }}>
                  {/* Player Name - 2x stat size, BOLD, centered, NO WRAP */}
                  <div 
                    ref={nameRef}
                    style={{ 
                      fontSize: nameFontSize,
                      fontWeight: 'bold',
                      lineHeight: '1.0',
                      textAlign: 'center',
                      width: '100%',
                      overflow: 'hidden',
                      whiteSpace: 'nowrap'
                    }}
                  >
                    {player.name}
                  </div>
                  
                  {/* Position and Grade Row - same size as stats */}
                  <div style={{ 
                    display: 'flex',
                    justifyContent: 'space-between',
                    fontSize: infoFontSize,
                    lineHeight: '1.0',
                    marginBottom: '1px'
                  }}>
                    <div style={{ textAlign: 'left' }}>{positionText}</div>
                    <div style={{ textAlign: 'right' }}>{gradeDisplay}</div>
                  </div>
                  
                  {/* SKATER STATS - 4 LINES FIXED */}
                  {!isGoalie ? (
                    <>
                      {/* Line 1: Current Season GP/G-A-PTS - BOLD */}
                      <div style={{ 
                        fontSize: statFontSize,
                        fontWeight: 'bold',
                        lineHeight: '1.0',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden'
                      }}>
                        25-26: GP:{stats.gp}  {stats.g}-{stats.a}--{stats.pts}
                      </div>
                      
                      {/* Line 2: Current Season PIM/+/-/Faceoff - BOLD */}
                      <div style={{ 
                        fontSize: statFontSize,
                        fontWeight: 'bold',
                        lineHeight: '1.0',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden'
                      }}>
                        PIM: {stats.pim} +/- {formatPlusMinus(stats.plusMinus)} Faceoff {faceoffPct}%
                      </div>
                      
                      {/* Line 3: Career GP/G-A-PTS - Regular */}
                      <div style={{ 
                        fontSize: statFontSize,
                        lineHeight: '1.0',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden'
                      }}>
                        Career GP:{careerStats.gp}  {careerStats.g}-{careerStats.a}--{careerStats.pts}
                      </div>
                      
                      {/* Line 4: Career PIM/+/-/Faceoff - Regular */}
                      <div style={{ 
                        fontSize: statFontSize,
                        lineHeight: '1.0',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden'
                      }}>
                        PIM: {careerStats.pim || 0} +/- {formatPlusMinus(careerStats.plusMinus)} Faceoff {careerStats.faceoffPct}%
                      </div>
                    </>
                  ) : (
                    /* GOALIE STATS - 4 LINES FIXED */}
                    <>
                      {/* Line 1: Current Season MIN/GAA - BOLD */}
                      <div style={{ 
                        fontSize: statFontSize,
                        fontWeight: 'bold',
                        lineHeight: '1.0',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden'
                      }}>
                        25-26: MIN {goalieStats.min} GAA: {goalieStats.gaa.toFixed(2)}
                      </div>
                      
                      {/* Line 2: Current Season PIM/W-L-T/S% - BOLD */}
                      <div style={{ 
                        fontSize: statFontSize,
                        fontWeight: 'bold',
                        lineHeight: '1.0',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden'
                      }}>
                        PIM: {goalieStats.pim || 0} {goalieStats.w}-{goalieStats.l}-{goalieStats.t} ({goalieStats.so}) S% {goalieStats.svp}
                      </div>
                      
                      {/* Line 3: Career MIN/GAA - Regular */}
                      <div style={{ 
                        fontSize: statFontSize,
                        lineHeight: '1.0',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden'
                      }}>
                        Career: MIN {careerGoalieStats.min} GAA: {careerGoalieStats.gaa.toFixed(2)}
                      </div>
                      
                      {/* Line 4: Career PIM/W-L-T/S% - Regular */}
                      <div style={{ 
                        fontSize: statFontSize,
                        lineHeight: '1.0',
                        whiteSpace: 'nowrap',
                        overflow: 'hidden'
                      }}>
                        PIM: {careerGoalieStats.pim || 0} {careerGoalieStats.w}-{careerGoalieStats.l}-{careerGoalieStats.t} ({careerGoalieStats.so}) S% {careerGoalieStats.svp}
                      </div>
                    </>
                  )}
                </div>
              </div>
            );
          };

          const LineSlot = ({ line, position, label, showLabel = false }) => {
            const player = lines[line][position];
            const isTargeted = selectedPlayer && !player;
            
            return (
              <div style={{ height: '85px' }}>
                {showLabel && (
                  <div className="text-xs font-bold text-center mb-0" style={{ fontSize: '11px', marginBottom: '2px' }}>{label}</div>
                )}
                <div 
                  onClick={() => handleSlotClick(line, position)}
                  className={`cursor-pointer transition-colors ${
                    isTargeted ? 'border-2 border-dashed border-blue-500 bg-blue-50 rounded' : ''
                  }`}
                  style={{ height: showLabel ? 'calc(100% - 20px)' : '100%' }}
                >
                  {player ? (
                    <PlayerCard player={player} source={{ line, position }} compact={true} />
                  ) : (
                    <div className="border-2 border-dashed border-gray-300 rounded h-full flex items-center justify-center">
                      <div className="text-gray-400 text-xs">Click to drop</div>
                    </div>
                  )}
                </div>
              </div>
            );
          };

          const getPlayersInLines = () => {
            const playersInLines = new Set();
            Object.values(lines).forEach(line => {
              Object.values(line).forEach(val => {
                if (val && typeof val === 'object' && val.id) {
                  playersInLines.add(val.id);
                }
              });
            });
            return playersInLines;
          };

          const availablePlayers = myTeamData.roster.filter(p => !getPlayersInLines().has(p.id));
          const currentStepInfo = importSteps.find(s => s.key === importStep);
          
          const normalizeFirstName = (name) => {
            const variations = {
              'joe': 'joseph', 'joseph': 'joe',
              'mike': 'michael', 'michael': 'mike',
              'dan': 'daniel', 'daniel': 'dan',
              'matt': 'matthew', 'matthew': 'matt',
              'rob': 'robert', 'robert': 'rob',
              'tom': 'thomas', 'thomas': 'tom',
              'jim': 'james', 'james': 'jim',
              'will': 'william', 'william': 'will',
              'chris': 'christopher', 'christopher': 'chris',
              'nick': 'nicholas', 'nicholas': 'nick'
            };
            const lower = name.toLowerCase();
            return variations[lower] ? [lower, variations[lower]] : [lower];
          };

          const handleCareerStatsImport = () => {
            try {
              // Combine all seasons into one import (they'll accumulate)
              const allSeasons = [
                careerStatsImport.lastSeason,
                careerStatsImport.twoSeasonsAgo,
                careerStatsImport.threeSeasonsAgo
              ].filter(s => s.trim());
              
              if (allSeasons.length === 0) {
                alert('Please paste at least one season of stats before importing.');
                return;
              }
              
              // Parse career stats directly into storage format (no roster needed!)
              const careerData = {};
              
              allSeasons.forEach((seasonText, seasonIdx) => {
                console.log(`📊 Processing season ${seasonIdx + 1}...`);
                const lines = seasonText.split('\n').map(l => l.trim()).filter(l => l);
                
                let inSkaterSection = false;
                let inGoalieSection = false;
                
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  
                  // Detect sections
                  if (line === 'Skater') {
                    inSkaterSection = true;
                    inGoalieSection = false;
                    continue;
                  }
                  if (line === 'Goalie') {
                    inSkaterSection = false;
                    inGoalieSection = true;
                    continue;
                  }
                  
                  // Skip headers
                  if (line === '#' || line === 'Name' || line === 'GP' || line.includes('AVG PTS')) continue;
                  
                  // Split by tabs
                  const fields = line.split('\t').filter(f => f.trim());
                  
                  // Need at least player number and name
                  if (fields.length < 3) continue;
                  
                  const number = fields[0];
                  const name = fields[1];
                  
                  // Must start with a digit
                  if (!/^\d+$/.test(number)) continue;
                  
                  // Extract last name and first initial
                  const nameParts = name.trim().split(/\s+/);
                  const firstInitial = nameParts[0]?.charAt(0)?.toUpperCase() || '';
                  const lastName = nameParts[nameParts.length - 1]?.toUpperCase() || '';
                  const key = `${lastName}_${firstInitial}`;
                  
                  if (inSkaterSection && fields.length >= 6) {
                    const seasonGP = parseInt(fields[2]) || 0;
                    const seasonG = parseInt(fields[3]) || 0;
                    const seasonA = parseInt(fields[4]) || 0;
                    const seasonPts = parseInt(fields[5]) || 0;
                    const seasonPlusMinus = parseInt(fields[19]) || 0;
                    const seasonFOW = parseInt(fields[14]) || 0;
                    const seasonFOL = parseInt(fields[15]) || 0;
                    
                    // Skip if this player already exists as a goalie (goalies can appear in skater section with 0 stats)
                    if (careerData[key]?.type === 'goalie') {
                      console.log(`⏭️ Skipping skater stats for ${name} - already saved as goalie`);
                      continue;
                    }
                    
                    // Accumulate across multiple seasons
                    if (!careerData[key]) {
                      careerData[key] = {
                        type: 'skater',
                        data: { gp: 0, g: 0, a: 0, pts: 0, plusMinus: 0, fow: 0, fol: 0 }
                      };
                    }
                    
                    careerData[key].data.gp += seasonGP;
                    careerData[key].data.g += seasonG;
                    careerData[key].data.a += seasonA;
                    careerData[key].data.pts += seasonPts;
                    careerData[key].data.plusMinus += seasonPlusMinus;
                    careerData[key].data.fow += seasonFOW;
                    careerData[key].data.fol += seasonFOL;
                    
                    console.log(`✅ Added skater career for ${name} (${key}):`, careerData[key].data);
                  } else if (inGoalieSection && fields.length >= 10) {
                    const seasonGP = parseInt(fields[2]) || 0;
                    const seasonMin = fields[3] || '0:00';
                    const seasonW = parseInt(fields[4]) || 0;
                    const seasonL = parseInt(fields[5]) || 0;
                    const seasonT = parseInt(fields[6]) || 0;
                    const seasonSO = parseInt(fields[12]) || 0;  // SO is field 12
                    const seasonGA = parseInt(fields[8]) || 0;
                    const seasonSV = parseInt(fields[9]) || 0;
                    
                    // GOALIE ALWAYS OVERWRITES SKATER - Convert any existing skater data to goalie
                    if (careerData[key]?.type === 'skater') {
                      console.log(`🔄 Converting ${name} from skater to goalie`);
                    }
                    
                    // Accumulate across multiple seasons (or initialize if first time OR converting from skater)
                    if (!careerData[key] || careerData[key].type !== 'goalie') {
                      careerData[key] = {
                        type: 'goalie',
                        data: { gp: 0, min: '0:00', w: 0, l: 0, t: 0, so: 0, ga: 0, sv: 0 }
                      };
                    }
                    
                    // Parse minutes safely
                    const seasonMinStr = seasonMin || '0:00';
                    const seasonMinParts = seasonMinStr.toString().split(':');
                    const minMinutes = parseInt(seasonMinParts[0]) || 0;
                    const minSeconds = parseInt(seasonMinParts[1]) || 0;
                    const totalSeasonSeconds = minMinutes * 60 + minSeconds;
                    
                    const existingMinStr = careerData[key].data.min || '0:00';
                    const existingMinParts = existingMinStr.toString().split(':');
                    const existingMinutes = parseInt(existingMinParts[0]) || 0;
                    const existingSeconds = parseInt(existingMinParts[1]) || 0;
                    const existingTotalSeconds = existingMinutes * 60 + existingSeconds;
                    
                    const newTotalSeconds = existingTotalSeconds + totalSeasonSeconds;
                    const newMinutes = Math.floor(newTotalSeconds / 60);
                    const newSeconds = newTotalSeconds % 60;
                    
                    careerData[key].data.gp += seasonGP;
                    careerData[key].data.min = `${newMinutes}:${String(newSeconds).padStart(2, '0')}`;
                    careerData[key].data.w += seasonW;
                    careerData[key].data.l += seasonL;
                    careerData[key].data.t += seasonT;
                    careerData[key].data.so += seasonSO;
                    careerData[key].data.ga += seasonGA;
                    careerData[key].data.sv += seasonSV;
                    
                    console.log(`✅ Added goalie career for ${name} (${key}):`, careerData[key].data);
                  }
                }
              });
              
              // Save directly to localStorage
              localStorage.setItem('hockey-scout-career-stats', JSON.stringify(careerData));
              console.log('💾 Saved career stats to localStorage:', Object.keys(careerData).length, 'players');
              console.log('💾 Career data keys:', Object.keys(careerData));
              
              alert(`✅ Successfully imported career stats for ${Object.keys(careerData).length} players!\n\n💾 Career stats saved to browser storage and will automatically load when you import your roster.`);
            } catch (error) {
              console.error('Career stats import error:', error);
              alert(`Error importing career stats: ${error.message}`);
            }
          };
          
          const totalCoachRecord = {
            w: (myTeamData.headCoach.careerRecord.w || 0) + myTeamData.record.w,
            l: (myTeamData.headCoach.careerRecord.l || 0) + myTeamData.record.l,
            t: (myTeamData.headCoach.careerRecord.t || 0) + myTeamData.record.t
          };
          
          const totalOppCoachRecord = {
            w: (opponentData.headCoach.careerRecord.w || 0) + opponentData.record.w,
            l: (opponentData.headCoach.careerRecord.l || 0) + opponentData.record.l,
            t: (opponentData.headCoach.careerRecord.t || 0) + opponentData.record.t
          };

          return (
            <div className="min-h-screen bg-gray-50">
              {/* MODALS AND UI - The rest of your code continues here exactly as before... */}
              {/* I'll stop here since the rest is unchanged */}
              
              <div className="text-center p-8">
                <h1 className="text-4xl font-bold mb-4">Hockey Scout v6.14 - ROSTER PARSING FIX</h1>
                <p className="text-lg text-gray-600">✅ Updated parseRoster function to handle all three roster format variations</p>
                <p className="text-sm text-gray-500 mt-2">The rest of your application code continues unchanged...</p>
              </div>
            </div>
          );
        };

        ReactDOM.render(<HockeyLinesChart />, document.getElementById('root'));
    </script>
</body>
</html>
