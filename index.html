<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MSHSL Legacy Lines v7</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            font-family: 'Arial Narrow', Arial, sans-serif;
        }
        
        /* Critical: Ensure colors print properly */
        @media print {
            /* Force yellow highlights to print */
            .bg-yellow-300, [style*="background-color: rgb(255, 255, 0)"], [style*="background-color: #FFFF00"] {
                background-color: #FFFF00 !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Force gray logo backgrounds to print */
            [style*="backgroundColor: '#EFEFEF'"], [style*="backgroundColor: '#efefef'"] {
                background-color: #EFEFEF !important;
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            
            /* Ensure all custom backgrounds print */
            * {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect } = React;

        // Error Boundary Component
        class ErrorBoundary extends React.Component {
          constructor(props) {
            super(props);
            this.state = { hasError: false, error: null };
          }

          static getDerivedStateFromError(error) {
            return { hasError: true, error };
          }

          componentDidCatch(error, errorInfo) {
            console.error('Error caught by boundary:', error, errorInfo);
          }

          render() {
            if (this.state.hasError) {
              return (
                <div style={{ padding: '20px', backgroundColor: '#fee', border: '2px solid #f00', margin: '20px' }}>
                  <h2>Something went wrong.</h2>
                  <details style={{ whiteSpace: 'pre-wrap' }}>
                    {this.state.error && this.state.error.toString()}
                  </details>
                  <button onClick={() => window.location.reload()} style={{ marginTop: '10px', padding: '8px 16px' }}>
                    Reload Application
                  </button>
                </div>
              );
            }
            return this.props.children;
          }
        }

        // SVG Icon Components
        const Upload = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M17 8l-5-5-5 5M12 3v12"/>
            </svg>
        );
        
        const Settings = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="3"/><path d="M12 1v6m0 6v6m5.2-13.8l-1 1.7m-4.4 7.6l-1 1.7M23 12h-6m-6 0H5m13.8 5.2l-1.7-1m-7.6-4.4l-1.7-1"/>
            </svg>
        );
        
        const Printer = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/>
            </svg>
        );

        const X = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        );

        const HockeyLinesChart = () => {
          const [myTeamSetup, setMyTeamSetup] = useState({
            teamName: 'Delano Tigers',
            logo: null,
            colors: { primary: '#fb923c', secondary: '#1f2937' },
            arena: 'Delano Area Sports Arena, Delano',
            careerStats: {},
            pronunciations: {},
            careerSeasonData: {
              season1: '',
              season2: '',
              season3: ''
            }
          });

          const [myTeamData, setMyTeamData] = useState({
            teamName: '',
            nickname: '',
            record: { w: 0, l: 0, t: 0 },
            section: '2A',
            conference: 'WCC',
            stats: { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 },
            roster: [],
            nextGame: { gameNum: '', opponent: '', date: '', location: '', oppRecord: '', oppSection: '', oppConference: '' },
            headCoach: { name: '', careerRecord: { w: 0, l: 0, t: 0 }, seasonRecord: { w: 0, l: 0, t: 0 } },
            assistantCoaches: [],
            studentManager: '',
            injuries: []
          });

          const [opponentData, setOpponentData] = useState({
            teamName: '',
            nickname: '',
            record: { w: 0, l: 0, t: 0 },
            section: '',
            conference: '',
            stats: { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 },
            roster: [],
            headCoach: { name: '', careerRecord: { w: 0, l: 0, t: 0 }, seasonRecord: { w: 0, l: 0, t: 0 } },
            assistantCoaches: []
          });

          const [lines, setLines] = useState({
            line1: { lw: null, c: null, rw: null, color: 'GREEN' },
            line2: { lw: null, c: null, rw: null, color: 'RED' },
            line3: { lw: null, c: null, rw: null, color: 'BLUE' },
            line4: { lw: null, c: null, rw: null, color: 'YELLOW' },
            d1: { ld: null, rd: null },
            d2: { ld: null, rd: null },
            d3: { ld: null, rd: null },
            goalies: { starter: null, backup: null }
          });

          const [coachNotes, setCoachNotes] = useState({
            pk: '',
            pp: '',
            scoutNotes: { powerPlay: '', penaltyKill: '', keyPlayers: '' },
            showScoutNotes: true
          });
          
          const [diagramImages, setDiagramImages] = useState({
            image1: null,
            image2: null,
            image3: null
          });

          const [showSetup, setShowSetup] = useState(false);
          const [showCareerStats, setShowCareerStats] = useState(false);
          const [showPronunciations, setShowPronunciations] = useState(false);
          const [showImport, setShowImport] = useState(false);
          const [showColorPicker, setShowColorPicker] = useState(false);
          const [showHelp, setShowHelp] = useState(false);
          const [helpContent, setHelpContent] = useState({ title: '', steps: [] });
          const [importStep, setImportStep] = useState('myTeamHome');
          const [importText, setImportText] = useState('');
          const [spreadsheetData, setSpreadsheetData] = useState([]);
          const [spreadsheetHeaders, setSpreadsheetHeaders] = useState([]);
          const [selectedPlayer, setSelectedPlayer] = useState(null);
          const [opponentLogo, setOpponentLogo] = useState(null);
          const [opponentColors, setOpponentColors] = useState({ primary: '#dc2626', secondary: '#991b1b' });
          const [careerStatsImport, setCareerStatsImport] = useState({
            lastSeason: '',
            twoSeasonsAgo: '',
            threeSeasonsAgo: ''
          });

          const colorOptions = ['GREEN', 'RED', 'BLUE', 'YELLOW', 'WHITE', 'BLACK', 'DARK GRAY', 'LIGHT GRAY'];
          const colorClasses = {
            'GREEN': 'bg-green-100 border-green-600',
            'RED': 'bg-red-100 border-red-600',
            'BLUE': 'bg-blue-100 border-blue-600',
            'YELLOW': 'bg-yellow-100 border-yellow-600',
            'WHITE': 'bg-white border-gray-800',
            'BLACK': 'bg-gray-900 border-gray-900',
            'DARK GRAY': 'bg-gray-600 border-gray-800',
            'LIGHT GRAY': 'bg-gray-200 border-gray-500'
          };

          const importSteps = [
            { key: 'myTeamHome', label: 'My Team - Legacy Home', team: 'mine' },
            { key: 'myTeamRoster', label: 'My Team - Legacy Roster', team: 'mine' },
            { key: 'myTeamPlayerStats', label: 'My Team - Legacy Player Stats', team: 'mine' },
            { key: 'oppLogo', label: 'Opponent - Logo', team: 'opponent', isLogo: true },
            { key: 'oppHome', label: 'Opponent - Legacy Home', team: 'opponent' },
            { key: 'oppRoster', label: 'Opponent - Legacy Roster', team: 'opponent' },
            { key: 'oppPlayerStats', label: 'Opponent - Legacy Player Stats', team: 'opponent' }
          ];

          // Help content for different sections
          const helpContents = {
            careerStats: {
              title: 'How to Import Career Stats',
              steps: [
                "Navigate to Legacy Hockey website",
                "Go to your team's Player Stats page for the {season} season",
                "Press Ctrl+A (Windows) or Command+A (Mac) to select all content",
                "Press Ctrl+C (Windows) or Command+C (Mac) to copy",
                "Return to Legacy Lines and paste here with Ctrl+V (Windows) or Command+V (Mac)"
              ]
            },
            myTeamHome: {
              title: 'How to Import Home Page Data',
              steps: [
                "Navigate to Legacy Hockey website",
                "Go to YOUR team's Home page",
                "Select all content (Ctrl+A or Command+A)",
                "Copy (Ctrl+C or Command+C)",
                "Return here and paste (Ctrl+V or Command+V)"
              ]
            },
            myTeamRoster: {
              title: 'How to Import Roster',
              steps: [
                "Go to your team's Roster page on Legacy Hockey",
                "Select all content (Ctrl+A or Command+A)",
                "Copy (Ctrl+C or Command+C)",
                "Return here and paste (Ctrl+V or Command+V)"
              ]
            },
            myTeamPlayerStats: {
              title: 'How to Import Player Stats',
              steps: [
                "Go to your team's Player Stats page on Legacy Hockey",
                "Select all content (Ctrl+A or Command+A)",
                "Copy (Ctrl+C or Command+C)",
                "Return here and paste (Ctrl+V or Command+V)"
              ]
            },
            oppHome: {
              title: 'How to Import Opponent Home Page Data',
              steps: [
                "Navigate to Legacy Hockey website",
                "Go to OPPONENT team Home page",
                "Select all content (Ctrl+A or Command+A)",
                "Copy (Ctrl+C or Command+C)",
                "Return here and paste (Ctrl+V or Command+V)"
              ]
            },
            oppRoster: {
              title: 'How to Import Opponent Roster',
              steps: [
                "Go to opponent team Roster page on Legacy Hockey",
                "Select all content (Ctrl+A or Command+A)",
                "Copy (Ctrl+C or Command+C)",
                "Return here and paste (Ctrl+V or Command+V)"
              ]
            },
            oppPlayerStats: {
              title: 'How to Import Opponent Player Stats',
              steps: [
                "Go to opponent team Player Stats page on Legacy Hockey",
                "Select all content (Ctrl+A or Command+A)",
                "Copy (Ctrl+C or Command+C)",
                "Return here and paste (Ctrl+V or Command+V)"
              ]
            }
          };

          // Load saved setup on mount
          useEffect(() => {
            try {
              const saved = localStorage.getItem('myTeamSetup');
              if (saved) {
                setMyTeamSetup(JSON.parse(saved));
              }
            } catch (error) {
              console.error('Error loading saved setup:', error);
            }
          }, []);

          // Save setup to localStorage whenever it changes
          useEffect(() => {
            try {
              localStorage.setItem('myTeamSetup', JSON.stringify(myTeamSetup));
            } catch (error) {
              console.error('Error saving setup:', error);
            }
          }, [myTeamSetup]);

          // Helper Functions
          const openHelp = (type, season = '') => {
            let content = { ...helpContents[type] };
            if (season) {
              content.steps = content.steps.map(step => step.replace('{season}', season));
            }
            setHelpContent(content);
            setShowHelp(true);
          };

          const getSeasonYears = () => {
            const now = new Date();
            const currentYear = now.getFullYear();
            const currentMonth = now.getMonth();
            
            let seasonStartYear;
            if (currentMonth >= 5) {
              seasonStartYear = currentYear - 1;
            } else {
              seasonStartYear = currentYear - 2;
            }
            
            return {
              season1: `${seasonStartYear}-${seasonStartYear + 1}`,
              season2: `${seasonStartYear - 1}-${seasonStartYear}`,
              season3: `${seasonStartYear - 2}-${seasonStartYear - 1}`
            };
          };

          const isSpreadsheetStep = (step) => {
            return false;
          };

          const handleSpreadsheetPaste = (text) => {
            console.log('=== Parsing spreadsheet paste ===');
            console.log('Raw text length:', text.length);
            
            const lines = text.split('\n').filter(l => l.trim());
            const rows = lines.map(line => line.split('\t'));
            
            if (rows.length > 0) {
              setSpreadsheetHeaders(rows[0]);
              setSpreadsheetData(rows.slice(1));
            }
          };

          const processSpreadsheetStats = (headers, data, existingRoster) => {
            const getColIndex = (possibleNames) => {
              return headers.findIndex(h => possibleNames.some(name => 
                h.toLowerCase().includes(name.toLowerCase())
              ));
            };
            
            const numCol = getColIndex(['#', 'number']);
            const nameCol = getColIndex(['name', 'player']);
            const gpCol = getColIndex(['gp']);
            const gCol = getColIndex(['g', 'goals']) !== -1 && !headers[getColIndex(['g', 'goals'])].toLowerCase().includes('ga') ? getColIndex(['g', 'goals']) : -1;
            const aCol = getColIndex(['a', 'assists']);
            const ptsCol = getColIndex(['pts', 'points']);
            const ppgCol = getColIndex(['ppg']);
            const ppaCol = getColIndex(['ppa']);
            const shCol = getColIndex(['sh']);
            const shaCol = getColIndex(['sha']);
            const pimCol = getColIndex(['pim', 'pen']);
            const plusMinusCol = getColIndex(['+/-', 'plus', 'minus']);
            const fowCol = getColIndex(['fow']);
            const folCol = getColIndex(['fol']);
            
            const updatedRoster = existingRoster.map(player => {
              const matchingRow = data.find(row => {
                const rowName = nameCol >= 0 ? row[nameCol] : '';
                const rowNum = numCol >= 0 ? row[numCol] : '';
                return rowName.includes(player.lastName) || rowNum === player.number;
              });
              
              if (matchingRow) {
                return {
                  ...player,
                  stats: {
                    gp: gpCol >= 0 ? parseInt(matchingRow[gpCol]) || 0 : 0,
                    g: gCol >= 0 ? parseInt(matchingRow[gCol]) || 0 : 0,
                    a: aCol >= 0 ? parseInt(matchingRow[aCol]) || 0 : 0,
                    pts: ptsCol >= 0 ? parseInt(matchingRow[ptsCol]) || 0 : 0,
                    ppg: ppgCol >= 0 ? parseInt(matchingRow[ppgCol]) || 0 : 0,
                    ppa: ppaCol >= 0 ? parseInt(matchingRow[ppaCol]) || 0 : 0,
                    sh: shCol >= 0 ? parseInt(matchingRow[shCol]) || 0 : 0,
                    sha: shaCol >= 0 ? parseInt(matchingRow[shaCol]) || 0 : 0,
                    pim: pimCol >= 0 ? parseInt(matchingRow[pimCol]) || 0 : 0,
                    plusMinus: plusMinusCol >= 0 ? parseInt(matchingRow[plusMinusCol]) || 0 : 0,
                    fow: fowCol >= 0 ? parseInt(matchingRow[fowCol]) || 0 : 0,
                    fol: folCol >= 0 ? parseInt(matchingRow[folCol]) || 0 : 0
                  }
                };
              }
              
              return player;
            });
            
            return updatedRoster;
          };

          // Career Stats localStorage helpers
          const saveCareerStatsToStorage = (roster) => {
            try {
              const careerData = {};
              roster.forEach(player => {
                const key = `${player.lastName?.toUpperCase()}_${player.firstName?.charAt(0)?.toUpperCase()}`;
                
                if (player.baseCareerStats && player.baseCareerStats.gp > 0) {
                  careerData[key] = {
                    type: 'skater',
                    data: player.baseCareerStats
                  };
                }
                
                if (player.baseCareerGoalieStats && player.baseCareerGoalieStats.gp > 0) {
                  careerData[key] = {
                    type: 'goalie',
                    data: player.baseCareerGoalieStats
                  };
                }
              });
              
              localStorage.setItem('hockey-scout-career-stats', JSON.stringify(careerData));
              console.log('ðŸ’¾ Saved career stats to localStorage:', Object.keys(careerData).length, 'players');
            } catch (error) {
              console.error('Error saving career stats:', error);
            }
          };
          
          const loadCareerStatsFromStorage = (roster) => {
            try {
              console.log('ðŸ” loadCareerStatsFromStorage CALLED with roster size:', roster.length);
              const stored = localStorage.getItem('hockey-scout-career-stats');
              
              if (!stored) {
                console.log('â„¹ No career stats in localStorage');
                return roster;
              }
              
              const careerData = JSON.parse(stored);
              console.log('ðŸ“‚ Loading career stats from localStorage:', Object.keys(careerData).length, 'players');
              
              return roster.map(player => {
                const key = `${player.lastName?.toUpperCase()}_${player.firstName?.charAt(0)?.toUpperCase()}`;
                const savedCareer = careerData[key];
                
                if (savedCareer) {
                  if (player.position === 'G' && savedCareer.type === 'goalie') {
                    player.baseCareerGoalieStats = savedCareer.data;
                    
                    // Calculate GAA and SVP for display
                    const parseMinutes = (minStr) => {
                      const parts = minStr.split(':');
                      return parseInt(parts[0]) * 60 + parseInt(parts[1] || 0);
                    };
                    const totalSeconds = parseMinutes(savedCareer.data.min || '0:00');
                    const totalMinutes = totalSeconds / 60;
                    const totalGA = savedCareer.data.ga || 0;
                    const totalSV = savedCareer.data.sv || 0;
                    const totalSOG = totalGA + totalSV;
                    
                    player.careerGoalieStats = {
                      ...savedCareer.data,
                      gaa: totalMinutes > 0 ? parseFloat((totalGA / (totalMinutes / 51)).toFixed(2)) : 0,
                      svp: totalSOG > 0 ? (totalSV / totalSOG).toFixed(3) : '.000'
                    };
                    console.log(`âœ“ Loaded GOALIE career for ${player.name}`);
                  } else if (savedCareer.type === 'skater') {
                    player.baseCareerStats = savedCareer.data;
                    
                    // Calculate faceoff % for display
                    const totalFOW = savedCareer.data.fow || 0;
                    const totalFOL = savedCareer.data.fol || 0;
                    player.careerStats = {
                      ...savedCareer.data,
                      faceoffPct: (totalFOW + totalFOL > 0) ? ((totalFOW / (totalFOW + totalFOL)) * 100).toFixed(1) : '0.0',
                      pim: savedCareer.data.pim || 0
                    };
                    console.log(`âœ“ Loaded SKATER career for ${player.name}`);
                  }
                }
                
                return player;
              });
            } catch (error) {
              console.error('Error loading career stats:', error);
              return roster;
            }
          };

          // Parsing Functions
          const parseHomePage = (text) => {
            try {
              const lines = text.split('\n').map(l => l.trim()).filter(l => l);
              let teamName = '';
              let nickname = '';
              let record = { w: 0, l: 0, t: 0 };
              let section = '';
              let conference = '';
              let headCoach = { name: '', careerRecord: { w: 0, l: 0, t: 0 }, seasonRecord: { w: 0, l: 0, t: 0 } };
              
              console.log('ðŸ“‹ ========== PARSING HOME PAGE ==========');
              console.log('ðŸ“‹ Total lines:', lines.length);
              
              // Find team name
              const subscribeIdx = lines.findIndex(l => l === 'Subscribe');
              if (subscribeIdx >= 0 && subscribeIdx + 1 < lines.length) {
                const potentialName = lines[subscribeIdx + 1];
                // Team name should be a substantial word, not a menu item
                if (potentialName && potentialName.length > 2 && 
                    !potentialName.includes('Home') && 
                    !potentialName.includes('Roster') &&
                    !potentialName.includes('Game') && 
                    !potentialName.includes('Â©') &&
                    !potentialName.includes('SportsEngine') &&
                    !potentialName.includes('powered by')) {
                  teamName = potentialName;
                  console.log('âœ… Found team name:', teamName);
                }
              }
              
              // If still no team name, look for it before "Home" menu item
              if (!teamName) {
                const homeIdx = lines.findIndex(l => l === 'Home');
                if (homeIdx > 0) {
                  const potentialName = lines[homeIdx - 1];
                  if (potentialName && potentialName.length > 2 && !potentialName.includes('Â©') &&
                      !potentialName.includes('SportsEngine') &&
                      !potentialName.includes('powered by')) {
                    teamName = potentialName;
                    console.log('âœ… Found team name (before Home):', teamName);
                  }
                }
              }
              
              // Find nickname
              const nicknameIdx = lines.findIndex(l => l.startsWith('Nickname:'));
              if (nicknameIdx >= 0) {
                nickname = lines[nicknameIdx].split(':')[1]?.trim() || '';
                console.log('âœ… Found nickname:', nickname);
              }
              
              // Find team record
              for (let i = 0; i < lines.length; i++) {
                if (lines[i].includes('Team Record') || lines[i] === 'W L T') {
                  for (let j = i + 1; j < i + 5 && j < lines.length; j++) {
                    const parts = lines[j]?.split(/\s+/);
                    if (parts && parts.length >= 3 && /^\d+$/.test(parts[0]) && /^\d+$/.test(parts[1]) && /^\d+$/.test(parts[2])) {
                      record = { w: parseInt(parts[0]), l: parseInt(parts[1]), t: parseInt(parts[2]) };
                      console.log('âœ… Found team record:', record);
                      break;
                    }
                  }
                  if (record.w > 0 || record.l > 0 || record.t > 0) break;
                }
              }
              
              // Find head coach
              const coachIdx = lines.findIndex(l => l.includes('Head Coach'));
              if (coachIdx >= 0) {
                let coachNameFound = false;
                for (let i = coachIdx + 1; i < coachIdx + 10 && i < lines.length; i++) {
                  const line = lines[i];
                  const careerMatch = line.match(/(\d+)(?:st|nd|rd|th)?\s+(?:season|year)[,\s]+(\d+)-(\d+)-(\d+)/i);
                  
                  if (careerMatch) {
                    if (!coachNameFound && i > coachIdx + 1) {
                      headCoach.name = lines[i - 1];
                      coachNameFound = true;
                    }
                    headCoach.careerRecord = { 
                      w: parseInt(careerMatch[2]), 
                      l: parseInt(careerMatch[3]), 
                      t: parseInt(careerMatch[4]) 
                    };
                    console.log('âœ… Found head coach:', headCoach.name, 'with career record:', headCoach.careerRecord);
                    break;
                  } else if (line.includes('1st Year') || line.includes('1st year') || line.match(/^1st\s+(?:season|year)/i)) {
                    if (!coachNameFound && i > coachIdx + 1) {
                      headCoach.name = lines[i - 1];
                    }
                    headCoach.careerRecord = { w: 0, l: 0, t: 0 };
                    console.log('âœ… Found first-year head coach:', headCoach.name);
                    break;
                  } else if (!coachNameFound && line && !line.includes('Head Coach') && line.length > 2 && !line.includes('Phone:')) {
                    headCoach.name = line;
                    coachNameFound = true;
                  }
                }
                
                headCoach.seasonRecord = { ...record };
              }
              
              const sectionIdx = lines.findIndex(l => l.includes('Section:'));
              if (sectionIdx >= 0) {
                section = lines[sectionIdx].split(':')[1]?.trim() || '';
              }
              
              const confIdx = lines.findIndex(l => l.includes('Conference:'));
              if (confIdx >= 0) {
                conference = lines[confIdx].split(':')[1]?.trim() || '';
              }
              
              // Parse Assistant Coaches
              let assistantCoaches = [];
              const assistantIdx = lines.findIndex(l => l.includes('Assistant Coaches:'));
              if (assistantIdx >= 0) {
                const assistantLine = lines[assistantIdx];
                const coachesPart = assistantLine.split('Assistant Coaches:')[1]?.trim();
                if (coachesPart) {
                  assistantCoaches = coachesPart.split(',').map(name => name.trim()).filter(name => name);
                }
              }
              
              // Parse Student Managers
              let studentManager = '';
              const managerIdx = lines.findIndex(l => l.includes('Student Managers:') || l.includes('Student Manager:'));
              if (managerIdx >= 0) {
                const managerLine = lines[managerIdx];
                const managersPart = managerLine.split(/Student Managers?:/)[1]?.trim();
                if (managersPart) {
                  studentManager = managersPart;
                  console.log('âœ… Found student managers:', studentManager);
                }
              }
              
              // Parse stats
              let stats = { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 };
              for (let i = 0; i < lines.length; i++) {
                const parts = lines[i].split(/\s+/);
                if (parts.length >= 10 && parts[0].match(/\d+/)) {
                  stats.gpg = parseFloat(parts[3]) || 0;
                  stats.gapg = parseFloat(parts[4]) || 0;
                  stats.ppPct = parseFloat(parts[6]) || 0;
                  stats.pkPct = parseFloat(parts[9]) || 0;
                  break;
                }
              }
              
              // Parse Last Game
              let lastGame = null;
              const lastGameIdx = lines.findIndex(l => l === 'Last Game');
              if (lastGameIdx >= 0) {
                const scoreLine = lines[lastGameIdx + 1];
                const scoreMatch = scoreLine?.match(/(\d+)\s*-\s*(\d+)/);
                
                if (scoreMatch) {
                  const leftScore = parseInt(scoreMatch[1]);
                  const rightScore = parseInt(scoreMatch[2]);
                  
                  let opponent = '';
                  const teamHeaderIdx = lines.findIndex((l, idx) => idx > lastGameIdx && l.includes('Team') && l.includes('1') && l.includes('2'));
                  
                  if (teamHeaderIdx > 0) {
                    for (let i = teamHeaderIdx + 1; i < Math.min(lines.length, teamHeaderIdx + 4); i++) {
                      const line = lines[i];
                      const teamMatch = line.match(/^([A-Za-z\/\s-]+?)\s+\d/);
                      if (teamMatch) {
                        const potentialTeam = teamMatch[1].trim();
                        if (potentialTeam.toLowerCase() !== teamName.toLowerCase()) {
                          opponent = potentialTeam.split(' ').map(word => 
                            word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                          ).join(' ');
                          break;
                        }
                      }
                    }
                  }
                  
                  if (!opponent) {
                    const finalIdx = lines.findIndex((l, idx) => idx > lastGameIdx && l === 'Final');
                    if (finalIdx > 0) {
                      for (let i = finalIdx + 1; i < Math.min(lines.length, finalIdx + 4); i++) {
                        const line = lines[i];
                        if (line && line.length > 2 && line !== teamName && !line.includes('202') && !line.includes('@')) {
                          opponent = line.split(' ').map(word => 
                            word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
                          ).join(' ');
                          break;
                        }
                      }
                    }
                  }
                  
                  let date = '';
                  let location = '';
                  for (let i = lastGameIdx + 3; i < Math.min(lines.length, lastGameIdx + 15); i++) {
                    if (lines[i].includes('@') && lines[i].includes('202')) {
                      const parts = lines[i].split('|');
                      date = parts[0]?.trim() || lines[i];
                      location = parts[1]?.trim() || '';
                      break;
                    }
                  }
                  
                  const ourScore = leftScore;
                  const oppScore = rightScore;
                  
                  lastGame = {
                    opponent,
                    ourScore,
                    oppScore,
                    result: ourScore > oppScore ? 'W' : ourScore < oppScore ? 'L' : 'T',
                    date,
                    location
                  };
                }
              }
              
              // Parse Next Game - Find ALL scheduled games, use SECOND one as 'next game'
              let nextGame = null;
              
              // Find all scheduled games
              const scheduledGames = [];
              for (let i = 0; i < lines.length; i++) {
                if (lines[i] === 'Scheduled' || lines[i].includes('@ ') && lines[i].match(/\d{1,2}:\d{2}/)) {
                  // Look backwards to find opponent and date
                  let opponent = '';
                  let date = '';
                  let time = '';
                  let isHome = false;
                  
                  // Check previous lines for opponent and date/time
                  for (let j = Math.max(0, i - 5); j < i; j++) {
                    const line = lines[j];
                    
                    // Date/time line format: "Sat Nov 22 @ 2:00pm"
                    if (line.includes('@') && line.match(/\d{1,2}:\d{2}/)) {
                      const parts = line.split('@');
                      date = parts[0]?.trim() || '';
                      time = parts[1]?.trim() || '';
                    }
                    
                    // Opponent line - look for team names (not "Delano-" or current team)
                    if (line && line.length > 2 && !line.includes(teamName) && !line.includes('@') && 
                        !line.match(/^\d/) && line !== 'Scheduled' && !line.includes(':')) {
                      if (line.endsWith('-')) {
                        opponent = line.slice(0, -1).trim();
                        // Determine home/away
                        const delanoline = lines[j-1];
                        if (delanoline && delanoline.includes(teamName + '-')) {
                          isHome = false;  // Team listed first = AWAY game
                        }
                      }
                    }
                  }
                  
                  if (opponent && date) {
                    scheduledGames.push({ opponent, isHome, date, time });
                  }
                }
              }
              
              console.log('ðŸ“… Found', scheduledGames.length, 'scheduled games');
              
              // Use the THIRD game to skip duplicate (Game 3)
              if (scheduledGames.length >= 3) {
                nextGame = {
                  ...scheduledGames[2],
                  gameNum: (record.w + record.l + record.t + 2).toString()  // Game 3 = actual next
                };
                console.log('âœ“ Next game (Game 3):', nextGame);
              } else if (scheduledGames.length >= 2) {
                nextGame = {
                  ...scheduledGames[1],
                  gameNum: (record.w + record.l + record.t + 2).toString()
                };
                console.log('âœ“ Next game (Game 2 fallback):', nextGame);
              } else if (scheduledGames.length === 1) {
                // Only one game scheduled (current game)
                nextGame = {
                  opponent: 'TBD',
                  isHome: false,
                  date: '',
                  time: '',
                  gameNum: (record.w + record.l + record.t + 2).toString()
                };
              } else {
                // Fallback to old parsing method
                const nextGameIdx = lines.findIndex(l => l === 'Next Game');
                if (nextGameIdx >= 0) {
                  let opponent = '';
                  let isHome = false;
                  let date = '';
                  let time = '';
                  
                  for (let i = nextGameIdx + 1; i < Math.min(lines.length, nextGameIdx + 10); i++) {
                    if (lines[i] === 'at') {
                      isHome = false;
                      for (let j = i + 1; j < Math.min(lines.length, i + 5); j++) {
                        if (lines[j] && lines[j].length > 2 && lines[j] !== teamName && !lines[j].includes('@')) {
                          opponent = lines[j];
                          break;
                        }
                      }
                      break;
                    } else if (lines[i] === 'vs') {
                      isHome = true;
                      for (let j = i + 1; j < Math.min(lines.length, i + 5); j++) {
                        if (lines[j] && lines[j].length > 2 && lines[j] !== teamName && !lines[j].includes('@')) {
                          opponent = lines[j];
                          break;
                        }
                      }
                      break;
                    }
                  }
                  
                  for (let i = nextGameIdx + 1; i < Math.min(lines.length, nextGameIdx + 15); i++) {
                    if (lines[i].includes('@') && (lines[i].includes(':') || lines[i].includes('p') || lines[i].includes('a'))) {
                      const parts = lines[i].split('@');
                      date = parts[0]?.trim() || '';
                      time = parts[1]?.trim() || '';
                      break;
                    }
                  }
                  
                  nextGame = {
                    opponent,
                    isHome,
                    date,
                    time,
                    gameNum: (record.w + record.l + record.t + 1).toString()
                  };
                }
              }
              
              console.log('ðŸ“‹ ========== PARSE COMPLETE ==========');
              
              return { teamName, nickname, record, section, conference, headCoach, assistantCoaches, studentManager, stats, lastGame, nextGame };
            } catch (error) {
              console.error('Error parsing home page:', error);
              return { 
                teamName: '', nickname: '', record: { w: 0, l: 0, t: 0 }, 
                section: '', conference: '', headCoach: { name: '', careerRecord: { w: 0, l: 0, t: 0 }, seasonRecord: { w: 0, l: 0, t: 0 } }, 
                assistantCoaches: [], stats: { ppPct: 0, pkPct: 0, gpg: 0, gapg: 0 }, lastGame: null, nextGame: null 
              };
            }
          };

          const parseRoster = (text, existingRoster = []) => {
            try {
              console.log('=== parseRoster called ===');
              const lines = text.split('\n').map(l => l.trim()).filter(l => l);
              console.log('Total lines:', lines.length);
              let roster = [];
              
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Try tab-separated first
                const fields = line.split('\t').map(f => f.trim()).filter(f => f);
                
                if (fields.length >= 4) {
                  // Tab-separated format
                  const number = fields[0];
                  const name = fields[1];
                  const position = fields[2];
                  const grade = fields[3];
                  
                  if (/^\d+$/.test(number) && /^[FDG]$/.test(position) && /^\d{1,2}$/.test(grade)) {
                    console.log('âœ“ Found player (tab-separated):', { number, name, position, grade });
                    
                    // Strip (Capt.) or (Capt) from names
                    const cleanName = name.replace(/\s*\(Capt\.?\)/i, '').trim();
                    const nameParts = cleanName.split(' ');
                    const lastName = nameParts[nameParts.length - 1];
                    const firstName = nameParts.slice(0, -1).join(' ');
                    
                    let handed = '';
                    let shoots = '';
                    
                    // Extract shoots/handed from correct column
                    for (let j = 5; j < fields.length; j++) {
                      const field = fields[j];
                      if (field === 'LC' || field.includes('Left Catch')) {
                        handed = 'L';
                        shoots = 'L';
                        console.log(`  â†’ Found shoots: LC for ${name}`);
                        break;
                      } else if (field === 'RC' || field.includes('Right Catch')) {
                        handed = 'R';
                        shoots = 'R';
                        console.log(`  â†’ Found shoots: RC for ${name}`);
                        break;
                      } else if (field === 'Left' || field === 'L') {
                        handed = 'L';
                        shoots = 'L';
                        console.log(`  â†’ Found shoots: Left for ${name}`);
                        break;
                      } else if (field === 'Right' || field === 'R') {
                        handed = 'R';
                        shoots = 'R';
                        console.log(`  â†’ Found shoots: Right for ${name}`);
                        break;
                      }
                    }
                    
                    let dobYear = '';
                    const lastField = fields[fields.length - 1];
                    const yearMatch = lastField.match(/\b(19|20)\d{2}\b/);
                    if (yearMatch) {
                      dobYear = yearMatch[0];
                    }
                    
                    const existingPlayer = existingRoster.find(p => 
                      p.lastName?.toUpperCase() === lastName.toUpperCase() && 
                      p.firstName?.charAt(0)?.toUpperCase() === firstName.charAt(0)?.toUpperCase()
                    );
                    
                    roster.push({
                      id: `${number}-${lastName}`,
                      number: number,
                      name: cleanName,
                      firstName: firstName,
                      lastName: lastName,
                      position: position,
                      grade: grade,
                      dobYear: dobYear,
                      handed: handed,
                      shoots: shoots,
                      stats: { gp: 0, g: 0, a: 0, pts: 0, ppg: 0, ppa: 0, sh: 0, sha: 0, pim: 0, plusMinus: 0, fow: 0, fol: 0 },
                      goalieStats: position === 'G' ? { gp: 0, min: '0:00', w: 0, l: 0, t: 0, sog: 0, ga: 0, sv: 0, gaa: 0, svp: '.000', so: 0 } : null,
                      baseCareerStats: existingPlayer?.baseCareerStats || undefined,
                      baseCareerGoalieStats: existingPlayer?.baseCareerGoalieStats || undefined,
                      pronunciation: existingPlayer?.pronunciation || undefined
                    });
                  }
                } else {
                  // Try concatenated format
                  const concatMatch = line.match(/^(\d+)([A-Za-z\s\-'\.]+?)([FDG])(\d{1,2})/);
                  
                  if (concatMatch) {
                    const number = concatMatch[1];
                    const name = concatMatch[2].trim();
                    const position = concatMatch[3];
                    const grade = concatMatch[4];
                    
                    const afterGrade = line.substring(line.indexOf(grade) + grade.length);
                    
                    let handed = '';
                    let shoots = '';
                    
                    const yearMatch = afterGrade.match(/\b(19|20)\d{2}\b/);
                    if (yearMatch) {
                      const beforeYear = afterGrade.substring(0, yearMatch.index);
                      
                      if (beforeYear.includes('LC')) {
                        handed = 'L';
                        shoots = 'L';
                      } else if (beforeYear.includes('RC')) {
                        handed = 'R';
                        shoots = 'R';
                      } else if (beforeYear.match(/Left(?![\w])/)) {
                        handed = 'L';
                        shoots = 'L';
                      } else if (beforeYear.match(/Right(?![\w])/)) {
                        handed = 'R';
                        shoots = 'R';
                      }
                    }
                    
                    let dobYear = '';
                    if (yearMatch) {
                      dobYear = yearMatch[0];
                    }
                    
                    console.log('âœ“ Found player (concatenated):', { number, name, position, grade, shoots, dobYear });
                    
                    const cleanName = name.replace(/\s*\(Capt\.?\)/i, '').trim();
                    const nameParts = cleanName.split(' ');
                    const lastName = nameParts[nameParts.length - 1];
                    const firstName = nameParts.slice(0, -1).join(' ');
                    
                    const existingPlayer = existingRoster.find(p => 
                      p.lastName?.toUpperCase() === lastName.toUpperCase() && 
                      p.firstName?.charAt(0)?.toUpperCase() === firstName.charAt(0)?.toUpperCase()
                    );
                    
                    roster.push({
                      id: `${number}-${lastName}`,
                      number: number,
                      name: cleanName,
                      firstName: firstName,
                      lastName: lastName,
                      position: position,
                      grade: grade,
                      dobYear: dobYear,
                      handed: handed,
                      shoots: shoots,
                      stats: { gp: 0, g: 0, a: 0, pts: 0, ppg: 0, ppa: 0, sh: 0, sha: 0, pim: 0, plusMinus: 0, fow: 0, fol: 0 },
                      goalieStats: position === 'G' ? { gp: 0, min: '0:00', w: 0, l: 0, t: 0, sog: 0, ga: 0, sv: 0, gaa: 0, svp: '.000', so: 0 } : null,
                      baseCareerStats: existingPlayer?.baseCareerStats || undefined,
                      baseCareerGoalieStats: existingPlayer?.baseCareerGoalieStats || undefined,
                      pronunciation: existingPlayer?.pronunciation || undefined
                    });
                  }
                }
              }
              
              console.log('Final roster size:', roster.length);
              return roster;
            } catch (error) {
              console.error('Error parsing roster:', error);
              return [];
            }
          };

          const parsePlayerStats = (text, existingRoster) => {
            try {
              console.log('=== parsePlayerStats called ===');
              const lines = text.split('\n').map(l => l.trim()).filter(l => l);
              
              const updatedRoster = [...existingRoster];
              let inSkaterSection = false;
              let inGoalieSection = false;
              
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (line === 'Skater') {
                  inSkaterSection = true;
                  inGoalieSection = false;
                  continue;
                }
                if (line === 'Goalie') {
                  inSkaterSection = false;
                  inGoalieSection = true;
                  continue;
                }
                
                if (line === '#' || line === 'Name' || line === 'GP' || line.includes('AVG PTS')) continue;
                
                const fields = line.split('\t').filter(f => f.trim());
                
                if (fields.length < 3) continue;
                
                const number = fields[0];
                const name = fields[1];
                
                if (!/^\d+$/.test(number)) continue;
                
                if (inSkaterSection) {
                  const player = updatedRoster.find(p => p.number === number && p.position !== 'G');
                  
                  if (player && fields.length >= 6) {
                    const currentStats = {
                      gp: parseInt(fields[2]) || 0,
                      g: parseInt(fields[3]) || 0,
                      a: parseInt(fields[4]) || 0,
                      pts: parseInt(fields[5]) || 0,
                      ppg: parseInt(fields[8]) || 0,
                      ppa: parseInt(fields[9]) || 0,
                      sh: parseInt(fields[10]) || 0,
                      sha: parseInt(fields[11]) || 0,
                      pim: parseInt(fields[13]) || 0,
                      fow: parseInt(fields[14]) || 0,
                      fol: parseInt(fields[15]) || 0,
                      plusMinus: parseInt(fields[19]) || 0
                    };
                    
                    player.stats = currentStats;
                    
                    const baseCareer = player.baseCareerStats || { gp: 0, g: 0, a: 0, pts: 0, plusMinus: 0, fow: 0, fol: 0, pim: 0 };
                    const totalFOW = (baseCareer.fow || 0) + currentStats.fow;
                    const totalFOL = (baseCareer.fol || 0) + currentStats.fol;
                    const careerFaceoffPct = (totalFOW + totalFOL > 0) ? ((totalFOW / (totalFOW + totalFOL)) * 100).toFixed(1) : '0.0';
                    
                    player.careerStats = {
                      gp: baseCareer.gp + currentStats.gp,
                      g: baseCareer.g + currentStats.g,
                      a: baseCareer.a + currentStats.a,
                      pts: baseCareer.pts + currentStats.pts,
                      plusMinus: baseCareer.plusMinus + currentStats.plusMinus,
                      faceoffPct: careerFaceoffPct,
                      fow: totalFOW,
                      fol: totalFOL,
                      pim: baseCareer.pim + currentStats.pim
                    };
                    
                    console.log(`âœ“ Updated ${name}:`, player.stats, 'Career:', player.careerStats);
                  }
                } else if (inGoalieSection) {
                  const player = updatedRoster.find(p => p.number === number && p.position === 'G');
                  
                  if (player && player.goalieStats && fields.length >= 10) {
                    const currentGoalieStats = {
                      gp: parseInt(fields[2]) || 0,
                      min: fields[3] || '0:00',
                      w: parseInt(fields[4]) || 0,
                      l: parseInt(fields[5]) || 0,
                      t: parseInt(fields[6]) || 0,
                      sog: parseInt(fields[7]) || 0,
                      ga: parseInt(fields[8]) || 0,
                      sv: parseInt(fields[9]) || 0,
                      gaa: parseFloat(fields[10]) || 0,
                      svp: fields[11] || '.000',
                      so: parseInt(fields[12]) || 0
                    };
                    
                    player.goalieStats = currentGoalieStats;
                    
                    const baseCareer = player.baseCareerGoalieStats || { gp: 0, min: '0:00', w: 0, l: 0, t: 0, so: 0, ga: 0, sv: 0 };
                    
                    const parseMinutes = (minStr) => {
                      const parts = minStr.split(':');
                      return parseInt(parts[0]) * 60 + parseInt(parts[1] || 0);
                    };
                    
                    const baseSeconds = parseMinutes(baseCareer.min);
                    const currSeconds = parseMinutes(currentGoalieStats.min);
                    const totalSeconds = baseSeconds + currSeconds;
                    const totalMinStr = `${Math.floor(totalSeconds / 60)}:${String(totalSeconds % 60).padStart(2, '0')}`;
                    
                    const totalGA = baseCareer.ga + currentGoalieStats.ga;
                    const totalSV = baseCareer.sv + currentGoalieStats.sv;
                    const totalSOG = totalGA + totalSV;
                    
                    const totalMinutes = totalSeconds / 60;
                    const careerGAA = totalMinutes > 0 ? (totalGA / (totalMinutes / 51)).toFixed(2) : '0.00';
                    const careerSVP = totalSOG > 0 ? (totalSV / totalSOG).toFixed(3) : '.000';
                    
                    player.careerGoalieStats = {
                      gp: baseCareer.gp + currentGoalieStats.gp,
                      min: totalMinStr,
                      w: baseCareer.w + currentGoalieStats.w,
                      l: baseCareer.l + currentGoalieStats.l,
                      t: baseCareer.t + currentGoalieStats.t,
                      so: baseCareer.so + currentGoalieStats.so,
                      ga: totalGA,
                      sv: totalSV,
                      gaa: parseFloat(careerGAA),
                      svp: careerSVP
                    };
                    
                    console.log(`âœ“ Updated goalie ${name}:`, player.goalieStats, 'Career:', player.careerGoalieStats);
                  }
                }
              }
              
              // V7 FIX 1: Update players already in lines when stats are imported
              setLines(prevLines => {
                const newLines = {...prevLines};
                let updated = false;
                
                ['line1', 'line2', 'line3', 'line4'].forEach(line => {
                  ['lw', 'c', 'rw'].forEach(pos => {
                    const playerInLine = newLines[line][pos];
                    if (playerInLine) {
                      const updatedPlayer = updatedRoster.find(p => p.id === playerInLine.id);
                      if (updatedPlayer) {
                        newLines[line][pos] = updatedPlayer;
                        updated = true;
                      }
                    }
                  });
                });
                
                ['d1', 'd2', 'd3'].forEach(line => {
                  ['ld', 'rd'].forEach(pos => {
                    const playerInLine = newLines[line][pos];
                    if (playerInLine) {
                      const updatedPlayer = updatedRoster.find(p => p.id === playerInLine.id);
                      if (updatedPlayer) {
                        newLines[line][pos] = updatedPlayer;
                        updated = true;
                      }
                    }
                  });
                });
                
                ['starter', 'backup'].forEach(pos => {
                  const playerInLine = newLines.goalies[pos];
                  if (playerInLine) {
                    const updatedPlayer = updatedRoster.find(p => p.id === playerInLine.id);
                    if (updatedPlayer) {
                      newLines.goalies[pos] = updatedPlayer;
                      updated = true;
                    }
                  }
                });
                
                return updated ? newLines : prevLines;
              });
              
              return updatedRoster;
            } catch (error) {
              console.error('Error parsing player stats:', error);
              return existingRoster;
            }
          };

          const parseCareerStats = (text, existingRoster) => {
            try {
              console.log('=== parseCareerStats called ===');
              const lines = text.split('\n').map(l => l.trim()).filter(l => l);
              
              const updatedRoster = [...existingRoster];
              let inSkaterSection = false;
              let inGoalieSection = false;
              
              for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (line === 'Skater') {
                  inSkaterSection = true;
                  inGoalieSection = false;
                  continue;
                }
                if (line === 'Goalie') {
                  inSkaterSection = false;
                  inGoalieSection = true;
                  continue;
                }
                
                if (line === '#' || line === 'Name' || line === 'GP' || line.includes('AVG PTS')) continue;
                
                const fields = line.split('\t').filter(f => f.trim());
                
                if (fields.length < 3) continue;
                
                const number = fields[0];
                const name = fields[1];
                
                if (!/^\d+$/.test(number)) continue;
                
                if (inSkaterSection) {
                  const normalizedNumber = number.trim();
                  const careerNameParts = name.trim().split(/\s+/);
                  const careerFirstInitial = careerNameParts[0]?.charAt(0)?.toUpperCase() || '';
                  const careerLastName = careerNameParts[careerNameParts.length - 1]?.toUpperCase() || '';
                  
                  let player = updatedRoster.find(p => {
                    if (p.position === 'G') return false;
                    
                    const rosterFirstInitial = p.firstName?.charAt(0)?.toUpperCase() || '';
                    const rosterLastName = p.lastName?.toUpperCase() || '';
                    
                    const nameMatch = rosterLastName === careerLastName && rosterFirstInitial === careerFirstInitial;
                    const numberMatch = p.number.toString().trim() === normalizedNumber;
                    
                    return nameMatch || numberMatch;
                  });
                  
                  if (player && fields.length >= 6) {
                    const seasonGP = parseInt(fields[2]) || 0;
                    const seasonG = parseInt(fields[3]) || 0;
                    const seasonA = parseInt(fields[4]) || 0;
                    const seasonPts = parseInt(fields[5]) || 0;
                    const seasonPIM = parseInt(fields[13]) || 0;
                    const seasonPlusMinus = parseInt(fields[19]) || 0;
                    const seasonFOW = parseInt(fields[14]) || 0;
                    const seasonFOL = parseInt(fields[15]) || 0;
                    
                    const existing = player.baseCareerStats || { gp: 0, g: 0, a: 0, pts: 0, pim: 0, plusMinus: 0, fow: 0, fol: 0 };
                    
                    player.baseCareerStats = {
                      gp: existing.gp + seasonGP,
                      g: existing.g + seasonG,
                      a: existing.a + seasonA,
                      pts: existing.pts + seasonPts,
                      pim: existing.pim + seasonPIM,
                      plusMinus: existing.plusMinus + seasonPlusMinus,
                      fow: existing.fow + seasonFOW,
                      fol: existing.fol + seasonFOL
                    };
                    
                    console.log(`âœ“ Base career for ${name}:`, player.baseCareerStats);
                  }
                } else if (inGoalieSection) {
                  const normalizedNumber = number.trim();
                  const careerNameParts = name.trim().split(/\s+/);
                  const careerFirstInitial = careerNameParts[0]?.charAt(0)?.toUpperCase() || '';
                  const careerLastName = careerNameParts[careerNameParts.length - 1]?.toUpperCase() || '';
                  
                  let player = updatedRoster.find(p => {
                    if (p.position !== 'G') return false;
                    
                    const rosterFirstInitial = p.firstName?.charAt(0)?.toUpperCase() || '';
                    const rosterLastName = p.lastName?.toUpperCase() || '';
                    
                    const nameMatch = rosterLastName === careerLastName && rosterFirstInitial === careerFirst
